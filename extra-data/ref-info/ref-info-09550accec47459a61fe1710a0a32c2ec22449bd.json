{
    "links": [
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1753394"
                        ],
                        "name": "D. Bobrow",
                        "slug": "D.-Bobrow",
                        "structuredName": {
                            "firstName": "Daniel",
                            "lastName": "Bobrow",
                            "middleNames": [
                                "G."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Bobrow"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145726521"
                        ],
                        "name": "J. B. Fraser",
                        "slug": "J.-B.-Fraser",
                        "structuredName": {
                            "firstName": "J.",
                            "lastName": "Fraser",
                            "middleNames": [
                                "Bruce"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. B. Fraser"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 952810,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "c718246790a35cd01c09859be9f36d31aa8df37b",
            "isKey": false,
            "numCitedBy": 72,
            "numCiting": 6,
            "paperAbstract": {
                "fragments": [],
                "text": "A syntactic analysis procedure is described which obtains directly the deep structure information associated with an input sentence. The implementation utilizes a state transition network characterizing those linguistic facts representable in a context free form, and a number of techniques to code and derive additional logic information and to permit the compression of the network size, thereby allowing more efficient operation of the system. By recognizing identical constituent predictions stemming from two different analysis paths, the system determines the structure of this constituent only once. When two alternative paths through the state transition network converge to a single state at some point In the analysis, subsequent analyses are carried out only once despite the earlier ambiguity. Use of flags to carry feature concordance and previous context information allows merging of a number of almost identical paths through the network."
            },
            "slug": "An-Augmented-State-Transition-Network-Analysis-Bobrow-Fraser",
            "title": {
                "fragments": [],
                "text": "An Augmented State Transition Network Analysis Procedure"
            },
            "tldr": {
                "abstractSimilarityScore": 95,
                "text": "A syntactic analysis procedure is described which obtains directly the deep structure information associated with an input sentence and utilizes a state transition network characterizing those linguistic facts representable in a context free form and a number of techniques to code and derive additional logic information and to permit the compression of the network size."
            },
            "venue": {
                "fragments": [],
                "text": "IJCAI"
            },
            "year": 1969
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144377863"
                        ],
                        "name": "G. H. Matthews",
                        "slug": "G.-H.-Matthews",
                        "structuredName": {
                            "firstName": "G.",
                            "lastName": "Matthews",
                            "middleNames": [
                                "H."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. H. Matthews"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 280,
                                "start": 276
                            }
                        ],
                        "text": "This model of transformational grammar is totally oriented toward the generation of sentences rather than their analysis, and although there is clearly an algorithm for the use of such a grammar to analyze a sentence--namely the procedure of \"analysis by synthesis\" (Matthews [23])--this algorithm is so inefficient as to be out of the question for any practical application."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 12353244,
            "fieldsOfStudy": [
                "Linguistics",
                "Computer Science"
            ],
            "id": "45b2f2b109c375193289febd8bc744a802f7f44d",
            "isKey": false,
            "numCitedBy": 9,
            "numCiting": 2,
            "paperAbstract": {
                "fragments": [],
                "text": "IN several previous papers, I have described a mechanical fail-safe sentence-recognition routine that, in principle, cannot fail to give all and only the possible syntactic analyses for any string of symbols with respect to a given grammar. The first part of this paper offers a slightly more precise formulation of this recognition routine. In the second part of this paper I describe some subroutines that make possible a practical analysis-by-synthesis computer programme. In the last part I discuss some advantages of this type of recognition routine over others that have been proposed. The analysis by synthesis of sentences is based upon the structural properties of grammars of natural languages. A grammar consists of a finite, though rather large, set of sentence-formation rules, i.e., grammatical rules. These rules provide for a denumerably infinite set of sentences, all of which draw their symbols from a single finite source, i.e., vocabulary. There are two kinds of vocabulary: Nonterminal vocabulary is found only in intermediate strings which occur during the derivation of a sentence. Only terminal vocabulary is found in sentences. (The term \"string\" refers to any sequence of terminal and/or nonterminal vocabulary, including sentences.) Another characteristic of grammars is that the grammatical rules are applied in a given linear order, and each rule transforms that string which is the result of all previous rules in the ordering. A rule consists of a finite set of subrules, one of which is applied at each application of the rule. The set of subrules that has been applied in the derivation of a string is essentially the syntactic structure of"
            },
            "slug": "Analysis-by-synthesis-of-natural-languages-Matthews",
            "title": {
                "fragments": [],
                "text": "Analysis by synthesis of natural languages"
            },
            "tldr": {
                "abstractSimilarityScore": 85,
                "text": "This paper offers a slightly more precise formulation of a mechanical fail-safe sentence-recognition routine that, in principle, cannot fail to give all and only the possible syntactic analyses for any string of symbols with respect to a given grammar."
            },
            "venue": {
                "fragments": [],
                "text": "EARLYMT"
            },
            "year": 1961
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145002066"
                        ],
                        "name": "D. Younger",
                        "slug": "D.-Younger",
                        "structuredName": {
                            "firstName": "Daniel",
                            "lastName": "Younger",
                            "middleNames": [
                                "H."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Younger"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 39351795,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e3411fd474131205af08d8ae52bc3d84de641866",
            "isKey": false,
            "numCitedBy": 23,
            "numCiting": 4,
            "paperAbstract": {
                "fragments": [],
                "text": "Three problems in language processing are the recognition of strings that are sentences of a given language, the parsing of sentences according to a given grammar, and the syntax-directed translation of sentences in one language to those in another. Limiting our attention to context-free languages, we consider first the simplest of these problems--recognition. A procedure is given whereby for an arbitrary string of length n and a specification of a context-free grammar, the string is recognized as generated by that grammar or not; the time, i.e. number of steps, required by this algorithm is proportional to n3. For a linear or metalinear grammar, this procedure is simplified to yield recognition in time Kn2. The algorithm for recognition is then extended to procedures for parsing and syntax-directed translation."
            },
            "slug": "Context-Free-Language-Processing-in-Time-n^3-Younger",
            "title": {
                "fragments": [],
                "text": "Context-Free Language Processing in Time n^3"
            },
            "tldr": {
                "abstractSimilarityScore": 47,
                "text": "The algorithm for recognition is extended to procedures for parsing and syntax-directed translation of sentences in one language to those in another, and to context-free languages."
            },
            "venue": {
                "fragments": [],
                "text": "SWAT"
            },
            "year": 1966
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "9079926"
                        ],
                        "name": "W. Woods",
                        "slug": "W.-Woods",
                        "structuredName": {
                            "firstName": "William",
                            "lastName": "Woods",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Woods"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 14297121,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "2913075d7fe608ec2964a7e8d68eea1a15d4bb52",
            "isKey": false,
            "numCitedBy": 104,
            "numCiting": 8,
            "paperAbstract": {
                "fragments": [],
                "text": "Simmons has presented a survey of some fifteen experimental question-answering and related systems which have been constructed since 1959. These systems take input questions in natural English (subject to varying constraints) and attempt to answer the questions on the basis of a body of information, called the data base, which is stored inside the computer. This process can be conceptually divided into three phases---syntatic analysis, semantic analysis, and retrieval, as illustrated schematically in Figure 1. The first phase consists of parsing the input sentence into a structure which explicitly represents the grammatical relationships among the words of the sentence. Using this information the second component constructs a representation of the semantic content or \"meaning\" of the sentence. The remaining phase consists of procedures for either retrieving the answer directly from the data base, or else deducing the answer from information contained in the data base. The dotted lines in the figure represent the possible use of feedback from the later stages to aid in parsing and semantic interpretation."
            },
            "slug": "Procedural-semantics-for-a-question-answering-Woods",
            "title": {
                "fragments": [],
                "text": "Procedural semantics for a question-answering machine"
            },
            "tldr": {
                "abstractSimilarityScore": 77,
                "text": "A survey of some fifteen experimental question-answering and related systems which have been constructed since 1959, which take input questions in natural English and attempt to answer the questions on the basis of a body of information, called the data base, which is stored inside the computer."
            },
            "venue": {
                "fragments": [],
                "text": "AFIPS '68 (Fall, part I)"
            },
            "year": 1968
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1717349"
                        ],
                        "name": "D. Knuth",
                        "slug": "D.-Knuth",
                        "structuredName": {
                            "firstName": "Donald",
                            "lastName": "Knuth",
                            "middleNames": [
                                "Ervin"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Knuth"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 14648496,
            "fieldsOfStudy": [
                "Computer Science",
                "Linguistics"
            ],
            "id": "fc230d6b4e6d275bff21b64dd0f457f07a92055f",
            "isKey": false,
            "numCitedBy": 834,
            "numCiting": 19,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "On-the-Translation-of-Languages-from-Left-to-Right-Knuth",
            "title": {
                "fragments": [],
                "text": "On the Translation of Languages from Left to Right"
            },
            "venue": {
                "fragments": [],
                "text": "Inf. Control."
            },
            "year": 1965
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2784211"
                        ],
                        "name": "S. Kuno",
                        "slug": "S.-Kuno",
                        "structuredName": {
                            "firstName": "Susumu",
                            "lastName": "Kuno",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Kuno"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 12536212,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "ccea36c0c514eb4cbd1e7e7572cb454feaad1f40",
            "isKey": false,
            "numCitedBy": 14,
            "numCiting": 14,
            "paperAbstract": {
                "fragments": [],
                "text": "A system is proposed here for assigning a derived P-marker to a given transformed sentence and obtaining the corresponding base P-marker at the same time. Rules of analytical phrase-structure grammar for such a system have associated with them information pertaining to the transformational histories of their own derivation. When a phrase-structure analysis of the sentence is obtained, the set of grammar rules used for the analysis contains all the information necessary for the direct mapping of the derived P-marker into the corresponding P-marker. The system can also be used for decomposing a given complex sentence into \"kernel\" sentences for the purpose of structure matching between a query sentence and stored document sentences in information retrieval. An experimental program for the proposed system has been written and is currently tested with a small sample grammar. Study is underway to see if there is any mechanical procedure for obtaining an analytical phrase structure grammar of the proposed type for a given transformational grammar."
            },
            "slug": "A-System-for-Transformational-Analysis-Kuno",
            "title": {
                "fragments": [],
                "text": "A System for Transformational Analysis"
            },
            "tldr": {
                "abstractSimilarityScore": 65,
                "text": "A system is proposed here for assigning a derived P- Marker to a given transformed sentence and obtaining the corresponding base P-marker at the same time and can be used for decomposing a given complex sentence into \"kernel\" sentences for the purpose of structure matching between a query sentence and stored document sentences in information retrieval."
            },
            "venue": {
                "fragments": [],
                "text": "COLING"
            },
            "year": 1965
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "114531657"
                        ],
                        "name": "Noam Chomsky",
                        "slug": "Noam-Chomsky",
                        "structuredName": {
                            "firstName": "Noam",
                            "lastName": "Chomsky",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Noam Chomsky"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 12867884,
            "fieldsOfStudy": [
                "Linguistics"
            ],
            "id": "16c762445f11fa2020994918dc4f93e76264df17",
            "isKey": false,
            "numCitedBy": 14181,
            "numCiting": 4,
            "paperAbstract": {
                "fragments": [],
                "text": "Abstract : Contents: Methodological preliminaries: Generative grammars as theories of linguistic competence; theory of performance; organization of a generative grammar; justification of grammars; formal and substantive grammars; descriptive and explanatory theories; evaluation procedures; linguistic theory and language learning; generative capacity and its linguistic relevance Categories and relations in syntactic theory: Scope of the base; aspects of deep structure; illustrative fragment of the base component; types of base rules Deep structures and grammatical transformations Residual problems: Boundaries of syntax and semantics; structure of the lexicon"
            },
            "slug": "\u0935\u093e\u0915\u094d\u092f\u0935\u093f\u0928\u094d\u092f\u093e\u0938-\u0915\u093e-\u0938\u0948\u0926\u094d\u0927\u093e\u0928\u094d\u0924\u093f\u0915-\u092a\u0915\u094d\u0937-=-Aspects-of-the-Chomsky",
            "title": {
                "fragments": [],
                "text": "Aspects of the Theory of Syntax"
            },
            "tldr": {
                "abstractSimilarityScore": 81,
                "text": "Methodological preliminaries of generative grammars as theories of linguistic competence; theory of performance; organization of a generative grammar; justification of grammar; descriptive and explanatory theories; evaluation procedures; linguistic theory and language learning."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1965
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "32406748"
                        ],
                        "name": "G. Ott",
                        "slug": "G.-Ott",
                        "structuredName": {
                            "firstName": "Gene",
                            "lastName": "Ott",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Ott"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "16898339"
                        ],
                        "name": "Neil H. Feinstein",
                        "slug": "Neil-H.-Feinstein",
                        "structuredName": {
                            "firstName": "Neil",
                            "lastName": "Feinstein",
                            "middleNames": [
                                "H."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Neil H. Feinstein"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 16238544,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "56b56b48d60e20ce4d2c7bb1121090cd632d9caa",
            "isKey": false,
            "numCitedBy": 42,
            "numCiting": 8,
            "paperAbstract": {
                "fragments": [],
                "text": "Procedures are given to convert any regular expression into a state diagram description and neural net realization of a machine that recognizes the regular set of sequences described by the given expression. It is established that any regular expression with a finite number of connectives describes a regular set of sequences that can be recognized by a finite state machine. All the procedures given are guaranteed to terminate in a finite number of steps, and a generalized computer program can be written to handle the entire conversion. An incidental result of the theory is the design of multiple output sequential machines. The potential usefulness of regular expressions and a long neglected form of a state diagram are demonstrated."
            },
            "slug": "Design-of-Sequential-Machines-from-Their-Regular-Ott-Feinstein",
            "title": {
                "fragments": [],
                "text": "Design of Sequential Machines from Their Regular Expressions"
            },
            "tldr": {
                "abstractSimilarityScore": 49,
                "text": "It is established that any regular expression with a finite number of connectives describes a regular set of sequences that can be recognized by a finite state machine."
            },
            "venue": {
                "fragments": [],
                "text": "JACM"
            },
            "year": 1961
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "38485274"
                        ],
                        "name": "T. Cheatham",
                        "slug": "T.-Cheatham",
                        "structuredName": {
                            "firstName": "Thomas",
                            "lastName": "Cheatham",
                            "middleNames": [
                                "E."
                            ],
                            "suffix": "Jr."
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Cheatham"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "11145340"
                        ],
                        "name": "K. Sattley",
                        "slug": "K.-Sattley",
                        "structuredName": {
                            "firstName": "Kirk",
                            "lastName": "Sattley",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Sattley"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 10482140,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "fb9dc1797fb2f3f8fe6aa9c02b60356897a96772",
            "isKey": false,
            "numCitedBy": 62,
            "numCiting": 16,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper is primarily concerned with the analysis of source statements in a programming language, although some of the ideas and techniques may be applicable to the analysis of source statements in a natural language. We are particularly concerned with those techniques which might be classed as predictive; the companion paper by Graham is concerned with other (\"nonpredictive\") techniques of analysis. Very broadly the techniques we will discuss operate as follows: Given a set of rules (Syntax Specification) for forming allowable constructs, eventually resulting in a statement (or sentence, word, program, etc.) of a language, we analyze a source statement in that language by guessing, or predicting, how the statement is constructed and either verifying that this is the case or backing up to try again, assuming some other method of construction. We keep a \"history\" of our attempts and when we have determined the exact way in which the statement is constructed we can use this \"history\" of its construction for further processing of the components of the statement."
            },
            "slug": "Syntax-directed-compiling-Cheatham-Sattley",
            "title": {
                "fragments": [],
                "text": "Syntax-directed compiling"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "The techniques discussed operate as follows: Given a set of rules for forming allowable constructs of a language, a source statement in that language is analyzed by guessing how the statement is constructed and either verifying that this is the case or backing up to try again, assuming some other method of construction."
            },
            "venue": {
                "fragments": [],
                "text": "AFIPS '64 (Spring)"
            },
            "year": 1964
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1699267"
                        ],
                        "name": "R. V. Book",
                        "slug": "R.-V.-Book",
                        "structuredName": {
                            "firstName": "Ronald",
                            "lastName": "Book",
                            "middleNames": [
                                "V."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. V. Book"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1733075"
                        ],
                        "name": "S. Even",
                        "slug": "S.-Even",
                        "structuredName": {
                            "firstName": "Shimon",
                            "lastName": "Even",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Even"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2408866"
                        ],
                        "name": "S. Greibach",
                        "slug": "S.-Greibach",
                        "structuredName": {
                            "firstName": "Sheila",
                            "lastName": "Greibach",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Greibach"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "32406748"
                        ],
                        "name": "G. Ott",
                        "slug": "G.-Ott",
                        "structuredName": {
                            "firstName": "Gene",
                            "lastName": "Ott",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Ott"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 20676251,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "526ca04dc8ba3a02d99735174b0a7b797bd9bbae",
            "isKey": false,
            "numCitedBy": 92,
            "numCiting": 12,
            "paperAbstract": {
                "fragments": [],
                "text": "A regular expression is called unambiguous if every tape in the event can be generated from the expression in one way only. The flow-graph technique for constructing an expression is shown to preserve ambiguities of the graph, and thus, if the graph is that of a deterministic automaton, the expression is unambiguous. A procedure for generating a nondeterministic automaton which preserves the ambiguities of the given regular expression is described. Finally, a procedure for testing whether a given expression is ambiguous is given."
            },
            "slug": "Ambiguity-in-Graphs-and-Expressions-Book-Even",
            "title": {
                "fragments": [],
                "text": "Ambiguity in Graphs and Expressions"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "The flow-graph technique for constructing an expression is shown to preserve ambiguities of the graph, and thus, if the graph is that of a deterministic automaton, the expression is unambiguous."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Transactions on Computers"
            },
            "year": 1971
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145436530"
                        ],
                        "name": "R. McNaughton",
                        "slug": "R.-McNaughton",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "McNaughton",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. McNaughton"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "93475256"
                        ],
                        "name": "H. Yamada",
                        "slug": "H.-Yamada",
                        "structuredName": {
                            "firstName": "Hisao",
                            "lastName": "Yamada",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. Yamada"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 42395383,
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "id": "13aa90ba21bd3acea714d7225ba32609debfa03d",
            "isKey": false,
            "numCitedBy": 533,
            "numCiting": 1,
            "paperAbstract": {
                "fragments": [],
                "text": "Algorithms are presented for 1) converting a state graph describing the behavior of an automaton to a regular expression describing the behavior of the same automaton (section 2), and 2) for converting a regular expression into a state graph (sections 3 and 4). These algorithms are justified by theorems, and examples are given. The first section contains a brief introduction to state graphs and the regular-expression language."
            },
            "slug": "Regular-Expressions-and-State-Graphs-for-Automata-McNaughton-Yamada",
            "title": {
                "fragments": [],
                "text": "Regular Expressions and State Graphs for Automata"
            },
            "tldr": {
                "abstractSimilarityScore": 95,
                "text": "Algorithms are presented for converting a state graph describing thebehavior of an automaton to a regular expression describing the behavior of the same automaton, and for converting an regular expression into a stategraph."
            },
            "venue": {
                "fragments": [],
                "text": "IRE Trans. Electron. Comput."
            },
            "year": 1960
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2612754"
                        ],
                        "name": "T. Kasami",
                        "slug": "T.-Kasami",
                        "structuredName": {
                            "firstName": "Tadao",
                            "lastName": "Kasami",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Kasami"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 143,
                                "start": 131
                            }
                        ],
                        "text": "Many of these results have been obtained by other algorithms which capitalize on special features of different classes of grammars [15, 16, 33], but the Earley algorithm is the only such algorithm which works for any given context-free grammar (with no restriction to special forms, absence of left-recursion, etc."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 61491815,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "af66165c454a0e94afbab36271fe3deaae0b421a",
            "isKey": false,
            "numCitedBy": 608,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "Abstract : An efficient algorithm of recognition and syntaxanalysis for the full class of context-free languages without the difficulty of exponential growth of computing time with the length n of input sequence is presented. This algorithm makes use of the essential property of a context-free language as a multi-parenthesis system. It is shown in this paper that a context-free language is n cubed-recognizable in the sense of Hartmanis and Stearns ('Computational complexity of recursive sequences'. Proc. Fifth Annual Symposium of Switching Circuit Theory and Logical Design (Oct. 1964) p.82-90) by a double-tape or double-head single-tape Turing machine and it is n to the 4th power-recognizable by a single-head single-tape Turing machine. If we use a random-access memory whose size is proportional to n cubed, the computing time required for syntaxanalysis is upperbounded by C(1)n cubed + C(2)n squared N, where N denotes the number of nonequivalent valid derivation sequences for a given input sequence and C(i)'s are constants independent of input sequences. If we use a tape of length C(3)n cubed and one of length C(4)n squared as working memories, the computing time for syntax-analysis is upperbounded by C(5)n cubed (1 + N). The size of required memory can be reduced to the order of n squared, but the computing time rises to the order of n to the 4th power. (Author)"
            },
            "slug": "An-Efficient-Recognition-and-Syntax-Analysis-for-Kasami",
            "title": {
                "fragments": [],
                "text": "An Efficient Recognition and Syntax-Analysis Algorithm for Context-Free Languages"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "It is shown in this paper that a context-free language is n cubed-recognizable in the sense of Hartmanis and Stearns and it is n to the 4th power- Recognizable by a single-head single-tape Turing machine."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1965
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2612754"
                        ],
                        "name": "T. Kasami",
                        "slug": "T.-Kasami",
                        "structuredName": {
                            "firstName": "Tadao",
                            "lastName": "Kasami",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Kasami"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                }
            ],
            "citationContexts": [],
            "corpusId": 29767267,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "dd81463f3559187a1e860f8c1110380d075c11e9",
            "isKey": false,
            "numCitedBy": 25,
            "numCiting": 8,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "A-Note-on-Computing-Time-for-Recognition-of-by-Kasami",
            "title": {
                "fragments": [],
                "text": "A Note on Computing Time for Recognition of Languages Generated by Linear Grammars"
            },
            "venue": {
                "fragments": [],
                "text": "Inf. Control."
            },
            "year": 1967
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143805236"
                        ],
                        "name": "J. McCarthy",
                        "slug": "J.-McCarthy",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "McCarthy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. McCarthy"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "[20]), a list processing programming language based on Church 's lambda cMculus and wri t ten in Cambridge Polish notation."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 60664055,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "83f054294ba2726d02aa03e471da773c3383b146",
            "isKey": false,
            "numCitedBy": 654,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "The LISP language is designed primarily for symbolic data processing used for symbolic calculations in differential and integral calculus, electrical circuit theory, mathematical logic, game playing, and other fields of artificial intelligence.The manual describes LISP, a formal mathematical language. LISP differs from most programming languages in three important ways. The first way is in the nature of the data. In the LISP language, all data are in the form of symbolic expressions usually referred to as S-expressions, of indefinite length, and which have a branching tree-type of structure, so that significant subexpressions can be readily isolated. In the LISP system, the bulk of the available memory is used for storing S-expressions in the form of list structures. The second distinction is that the LISP language is the source language itself which specifies in what way the S-expressions are to be processed. Third, LISP can interpret and execute programs written in the form of S-expressions. Thus, like machine language, and unlike most other high level languages, it can be used to generate programs for further executions."
            },
            "slug": "LISP-1.5-Programmer's-Manual-McCarthy",
            "title": {
                "fragments": [],
                "text": "LISP 1.5 Programmer's Manual"
            },
            "tldr": {
                "abstractSimilarityScore": 100,
                "text": "The LISP language is designed primarily for symbolic data processing used for symbolic calculations in differential and integral calculus, electrical circuit theory, mathematical logic, game playing, and other fields of artificial intelligence."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1962
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "4820311"
                        ],
                        "name": "R. Schwarcz",
                        "slug": "R.-Schwarcz",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "Schwarcz",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Schwarcz"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 15570197,
            "fieldsOfStudy": [
                "Linguistics"
            ],
            "id": "9413c1bd6ef9fa77316083bc719e9eaff029791c",
            "isKey": false,
            "numCitedBy": 9,
            "numCiting": 26,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper discusses the task of formulating a model of linguistic performance and proposes an approach toward this goal that is oriented toward an embodiment of the model as a digital-computer program. The methodology of current linguistic theory is criticized for several of its features that render it inapplicable to a realistic model of performance, and remedies for these deficiencies are proposed. The syntactic- and conceptual-data structures, inference rules, generation and understanding mechanisms, and learning mechanisms proposed for the model are all described. The learning process is formulated as a series of five stages, and the roles of non-linguistic feedback and inductive generalization relative to these stages are described. Finally, the implications of a successful performance model for linguistic theory, linguistic applications of computers, and psychological theory are discussed."
            },
            "slug": "Steps-toward-a-model-of-linguistic-performance:-a-Schwarcz",
            "title": {
                "fragments": [],
                "text": "Steps toward a model of linguistic performance: a preliminary sketch"
            },
            "tldr": {
                "abstractSimilarityScore": 100,
                "text": "This paper discusses the task of formulating a model of linguistic performance and proposes an approach toward this goal that is oriented toward an embodiment of the model as a digital-computer program."
            },
            "venue": {
                "fragments": [],
                "text": "Mech. Transl. Comput. Linguistics"
            },
            "year": 1967
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "49843410"
                        ],
                        "name": "M. E. Conway",
                        "slug": "M.-E.-Conway",
                        "structuredName": {
                            "firstName": "Melvin",
                            "lastName": "Conway",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. E. Conway"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 10559786,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "5f06aeb2a5fd62a9d34ba303be5524b8f3734eeb",
            "isKey": false,
            "numCitedBy": 451,
            "numCiting": 22,
            "paperAbstract": {
                "fragments": [],
                "text": "A COBOL compiler design is presented which is compact enough to permit rapid, one-pass compilation of a large subset of COBOL on a moderately large computer. Versions of the same compiler for smaller machines require only two working tapes plus a compiler tape. The methods given are largely applicable to the construction of ALGOL compilers."
            },
            "slug": "Design-of-a-separable-transition-diagram-compiler-Conway",
            "title": {
                "fragments": [],
                "text": "Design of a separable transition-diagram compiler"
            },
            "tldr": {
                "abstractSimilarityScore": 100,
                "text": "A COBol compiler design is presented which is compact enough to permit rapid, one-pass compilation of a large subset of COBOL on a moderately large computer."
            },
            "venue": {
                "fragments": [],
                "text": "CACM"
            },
            "year": 1963
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 115,
                                "start": 111
                            }
                        ],
                        "text": ") Two attempts to formulate more practical algorithms for transformational recognition (Petriek [26] and Mitre [24]) resulted in algorithms which were either too time consuming for the analysis of large numbers of sentences or"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 12,
                                "start": 7
                            }
                        ],
                        "text": "In the Mitre procedure, the augmented grammar is used to assign a complete \"tentative\" surface structure \nwhich is then subjected to inverse transformations."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 108,
                                "start": 103
                            }
                        ],
                        "text": "Two attempts to formulate more practical algorithms \nfor transformational recognition (Petriek [26] and Mitre [24]) resulted in algorithms which were either \ntoo time con- suming for the analysis of large numbers of sentences or else lacking in formal completeness."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 14,
                                "start": 9
                            }
                        ],
                        "text": "Both the Mitre and the Petrick \nanalysis procedures solve this problem by con-structing an \"augmented grammar\" which consists of the \nrules of the original base component grammar plus addi- tional rules which characterize the structures \nthat can be added by transformations."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 12,
                                "start": 7
                            }
                        ],
                        "text": "In the Mitre procedure, this \"surface grammar\" is constructed by \nhand and no formal procedure is available for constructing it from the original transformational grammar."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 51,
                                "start": 46
                            }
                        ],
                        "text": "English preprocessor manual, Rep. SR-132, The Mitre Corp., Bedford, Mass., \n1964."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 9,
                                "start": 4
                            }
                        ],
                        "text": "The Mitre parser avoids the nondeterminism of the inverse transformational \nprocess by constructing a de-terministic set of inverse transformational rules ad hoc to a particular \ngrammar."
                    },
                    "intents": []
                }
            ],
            "fieldsOfStudy": [],
            "isKey": true,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "preprocessor manual, Rep"
            },
            "venue": {
                "fragments": [],
                "text": "SR-132, The Mitre Corp., Bedford, Mass.,"
            },
            "year": 1964
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "9079926"
                        ],
                        "name": "W. Woods",
                        "slug": "W.-Woods",
                        "structuredName": {
                            "firstName": "William",
                            "lastName": "Woods",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Woods"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 52,
                                "start": 44
                            }
                        ],
                        "text": "semantic interpretation (described in Woods [30, 31]),"
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 73,
                                "start": 68
                            }
                        ],
                        "text": "By using \nstandard finite state machine optimization techniques (see Woods [32]) it is possible to \"optimize\" the \ntransition network by making it deterministic except for the pushdown operations (where nondeterminism \ncan be reduced but not necessarily eliminated)."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 98,
                                "start": 93
                            }
                        ],
                        "text": "The implemented system contains a general \nfacility for semantic interpretation (described in Woods [30, 31]), and a major motivation for the implementation \nis to explore the interaction between the syntactic and semantic aspects of the process of sentence \"understanding\"."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 24,
                                "start": 19
                            }
                        ],
                        "text": "We give elsewhere (Woods \n[32]) a modified version of the Earley algorithm which can be used to parse sentences with respect to \nan (unaugmented) transition network grammar within the same time bounds, and we show there that a number \nof mechanical \"optimization\" techniques can be applied to a transition network grammar to reduce the \nconstant of proportionality in the time bound."
                    },
                    "intents": []
                }
            ],
            "corpusId": 25168914,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "34fe9525a886d0bf7c97d180c0e6e7d75d0abb8e",
            "isKey": false,
            "numCitedBy": 46,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Semantics-For-a-Question-Answering-System-Woods",
            "title": {
                "fragments": [],
                "text": "Semantics For a Question-Answering System"
            },
            "venue": {
                "fragments": [],
                "text": "Outstanding Dissertations in the Computer Sciences"
            },
            "year": 1967
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145293233"
                        ],
                        "name": "S. Ginsburg",
                        "slug": "S.-Ginsburg",
                        "structuredName": {
                            "firstName": "Seymour",
                            "lastName": "Ginsburg",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Ginsburg"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 61616162,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "6be47b5305379c52961c15d80781f55849d9f758",
            "isKey": false,
            "numCitedBy": 1088,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "The-mathematical-theory-of-context-free-languages-Ginsburg",
            "title": {
                "fragments": [],
                "text": "The mathematical theory of context free languages"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1966
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "9079926"
                        ],
                        "name": "W. Woods",
                        "slug": "W.-Woods",
                        "structuredName": {
                            "firstName": "William",
                            "lastName": "Woods",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Woods"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 59791958,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "75b6c65a28cb49e34b170ea696be536dc9b45736",
            "isKey": false,
            "numCitedBy": 33,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Augmented-Transition-Networks-for-Natural-Language-Woods",
            "title": {
                "fragments": [],
                "text": "Augmented Transition Networks for Natural Language Analysis."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1969
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2199081"
                        ],
                        "name": "S. R. Petrick",
                        "slug": "S.-R.-Petrick",
                        "structuredName": {
                            "firstName": "Stanley",
                            "lastName": "Petrick",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. R. Petrick"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 100,
                                "start": 96
                            }
                        ],
                        "text": ") Two attempts to formulate more practical algorithms for transformational recognition (Petriek [26] and Mitre [24]) resulted in algorithms which were either too time consuming for the analysis of large numbers of sentences or"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 53772050,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "6c4f43d484ac3fc5f277a2fe4305aebb6373970e",
            "isKey": false,
            "numCitedBy": 61,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "A-recognition-procedure-for-transformational-Petrick",
            "title": {
                "fragments": [],
                "text": "A recognition procedure for transformational grammars."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1965
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2912454"
                        ],
                        "name": "C. Fillmore",
                        "slug": "C.-Fillmore",
                        "structuredName": {
                            "firstName": "Charles",
                            "lastName": "Fillmore",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Fillmore"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "The explicit structure-building actions on the arcs of the network allow one to experiment with different syntactic representations such as dependency grammars, tagmemic formulas, or Fillmore's case grammar [ 11 ]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 61363578,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "d53cfca137c38f82361878a67ea47002e9940e34",
            "isKey": false,
            "numCitedBy": 2409,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "THE-CASE-FOR-CASE.-Fillmore",
            "title": {
                "fragments": [],
                "text": "THE CASE FOR CASE."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1967
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "path syntactic analyzer"
            },
            "venue": {
                "fragments": [],
                "text": "In Information Processing 1062, North-Holland Publishing Co., Amsterdam,"
            },
            "year": 1963
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Limitations of phrase structure grammars"
            },
            "venue": {
                "fragments": [],
                "text": "The Structure of Language"
            },
            "year": 1964
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Formal properties of grammars"
            },
            "venue": {
                "fragments": [],
                "text": "In Handbook of Mathematical Psychology,"
            },
            "year": 1963
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Aspects of the Theory of Syntaz"
            },
            "venue": {
                "fragments": [],
                "text": "Aspects of the Theory of Syntaz"
            },
            "year": 1965
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The immediate constituent analyzer"
            },
            "venue": {
                "fragments": [],
                "text": "The immediate constituent analyzer"
            },
            "year": 1966
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "QUOTE HAVE)))"
            },
            "venue": {
                "fragments": [],
                "text": "QUOTE HAVE)))"
            }
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "A transformational approach to syntax"
            },
            "venue": {
                "fragments": [],
                "text": "The Structure of Language"
            },
            "year": 1963
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "English preprocessor manual, Rep. SR-132, The Mitre Corp"
            },
            "venue": {
                "fragments": [],
                "text": "English preprocessor manual, Rep. SR-132, The Mitre Corp"
            },
            "year": 1964
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "A simple proof of the standard-form theorem for context-free grammars"
            },
            "venue": {
                "fragments": [],
                "text": "Mathematical linguistics and automatic translation, Rep. NSE-18"
            },
            "year": 1967
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "QUOTE BE)))"
            },
            "venue": {
                "fragments": [],
                "text": "QUOTE BE)))"
            }
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "TRANS (GETR V)"
            },
            "venue": {
                "fragments": [],
                "text": "TRANS (GETR V)"
            }
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Formal properties of grammars A transformational approach to syntax"
            },
            "venue": {
                "fragments": [],
                "text": "Handbook of Mathematical Psychology"
            },
            "year": 1963
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Ambiguity in graphs and expressions. Mimeo. rep"
            },
            "venue": {
                "fragments": [],
                "text": "Ambiguity in graphs and expressions. Mimeo. rep"
            },
            "year": 1969
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Meaning and the description of languages"
            },
            "venue": {
                "fragments": [],
                "text": "Kotoba No Ucho"
            },
            "year": 1968
        }
    ],
    "meta_info": {
        "citationIntent": "all",
        "citationIntentCount": {
            "background": 4,
            "methodology": 2
        },
        "citationType": "citedPapers",
        "pageNumber": 1,
        "requestedPageSize": 10,
        "sort": "relevance",
        "totalCitations": 36,
        "totalPages": 4
    },
    "page_url": "https://www.semanticscholar.org/paper/Transition-network-grammars-for-natural-language-Woods/09550accec47459a61fe1710a0a32c2ec22449bd?sort=total-citations"
}
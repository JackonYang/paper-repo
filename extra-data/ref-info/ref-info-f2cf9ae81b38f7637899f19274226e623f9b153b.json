{
    "links": [
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1398564680"
                        ],
                        "name": "R. Cameron-Jones",
                        "slug": "R.-Cameron-Jones",
                        "structuredName": {
                            "firstName": "R.",
                            "lastName": "Cameron-Jones",
                            "middleNames": [
                                "Mike"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Cameron-Jones"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145341779"
                        ],
                        "name": "J. R. Quinlan",
                        "slug": "J.-R.-Quinlan",
                        "structuredName": {
                            "firstName": "J.",
                            "lastName": "Quinlan",
                            "middleNames": [
                                "Ross"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. R. Quinlan"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 11138624,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "4af318f1d267889faec6ecf1be6bc5fe570838dd",
            "isKey": false,
            "numCitedBy": 46,
            "numCiting": 10,
            "paperAbstract": {
                "fragments": [],
                "text": "Learning systems that express theories in rst-order logic must ensure that the theories are executable and, in particular, that they do not lead to innnite recursion. This paper presents a heuristic method for preventing innnite re-cursion in the (multi-clause) deenition of a recursive relation. The method has been implemented in the latest version of foil, but could also be used with any learning method that grows clauses from ground facts by repeated specialization. Results on several examples, including Ackermann's function, are presented."
            },
            "slug": "Avoiding-Pitfalls-When-Learning-Recursive-Theories-Cameron-Jones-Quinlan",
            "title": {
                "fragments": [],
                "text": "Avoiding Pitfalls When Learning Recursive Theories"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "This paper presents a heuristic method for preventing innnite re-cursion in the (multi-clause) deenition of a recursive relation."
            },
            "venue": {
                "fragments": [],
                "text": "IJCAI"
            },
            "year": 1993
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145147566"
                        ],
                        "name": "S. Muggleton",
                        "slug": "S.-Muggleton",
                        "structuredName": {
                            "firstName": "Stephen",
                            "lastName": "Muggleton",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Muggleton"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "70219052"
                        ],
                        "name": "Wray L. Buntine",
                        "slug": "Wray-L.-Buntine",
                        "structuredName": {
                            "firstName": "Wray",
                            "lastName": "Buntine",
                            "middleNames": [
                                "L."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Wray L. Buntine"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 109,
                                "start": 83
                            }
                        ],
                        "text": "FOIL has no facilities for inventing new predicates, but the promising research of Muggleton and Buntine 1988], Kietz and Morik 1993] and others suggests that such facilities may be able to be grafted on."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 6159430,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e340a9b752f9b358cda4dc7a1c6e3c6280867158",
            "isKey": false,
            "numCitedBy": 599,
            "numCiting": 10,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Machine-Invention-of-First-Order-Predicates-by-Muggleton-Buntine",
            "title": {
                "fragments": [],
                "text": "Machine Invention of First Order Predicates by Inverting Resolution"
            },
            "venue": {
                "fragments": [],
                "text": "ML"
            },
            "year": 1988
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1683540"
                        ],
                        "name": "B. Kijsirikul",
                        "slug": "B.-Kijsirikul",
                        "structuredName": {
                            "firstName": "Boonserm",
                            "lastName": "Kijsirikul",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Kijsirikul"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "9136228"
                        ],
                        "name": "M. Numao",
                        "slug": "M.-Numao",
                        "structuredName": {
                            "firstName": "Masayuki",
                            "lastName": "Numao",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Numao"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1845202"
                        ],
                        "name": "M. Shimura",
                        "slug": "M.-Shimura",
                        "structuredName": {
                            "firstName": "Masamichi",
                            "lastName": "Shimura",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Shimura"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 40043489,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "7f32933aed4be6c4fc4ef8e5d60cf45777475a52",
            "isKey": false,
            "numCitedBy": 26,
            "numCiting": 2,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Efficient-Learning-of-Logic-Programs-with-Literals-Kijsirikul-Numao",
            "title": {
                "fragments": [],
                "text": "Efficient Learning of Logic Programs with Non-determinant, Non-discriminating Literals"
            },
            "venue": {
                "fragments": [],
                "text": "ML"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "34615574"
                        ],
                        "name": "B. Richards",
                        "slug": "B.-Richards",
                        "structuredName": {
                            "firstName": "Bradley",
                            "lastName": "Richards",
                            "middleNames": [
                                "L."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Richards"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1797655"
                        ],
                        "name": "R. Mooney",
                        "slug": "R.-Mooney",
                        "structuredName": {
                            "firstName": "Raymond",
                            "lastName": "Mooney",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Mooney"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 43572330,
            "fieldsOfStudy": [
                "Philosophy"
            ],
            "id": "be818f724d5d8185cc1edf05fd28886079d76b29",
            "isKey": false,
            "numCitedBy": 95,
            "numCiting": 6,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "First-Order-Theory-Revision-Richards-Mooney",
            "title": {
                "fragments": [],
                "text": "First-Order Theory Revision"
            },
            "venue": {
                "fragments": [],
                "text": "ML"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145341779"
                        ],
                        "name": "J. R. Quinlan",
                        "slug": "J.-R.-Quinlan",
                        "structuredName": {
                            "firstName": "J.",
                            "lastName": "Quinlan",
                            "middleNames": [
                                "Ross"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. R. Quinlan"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 5443909,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "381044240ce5b34a78995ea07c2562fafb1b8a6a",
            "isKey": false,
            "numCitedBy": 110,
            "numCiting": 8,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Determinate-Literals-in-Inductive-Logic-Programming-Quinlan",
            "title": {
                "fragments": [],
                "text": "Determinate Literals in Inductive Logic Programming"
            },
            "venue": {
                "fragments": [],
                "text": "IJCAI"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1725040"
                        ],
                        "name": "I. Bratko",
                        "slug": "I.-Bratko",
                        "structuredName": {
                            "firstName": "Ivan",
                            "lastName": "Bratko",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "I. Bratko"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 151,
                                "start": 139
                            }
                        ],
                        "text": "As a step towards a more pragmatic evaluation, we started with Ivan Bratko's well-known text Prolog Programming for Artiicial Intelligence Bratko, 1986]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 61139322,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "0d839753b1de2070810b97c3ca05c6b78f861667",
            "isKey": false,
            "numCitedBy": 823,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Prolog-Programming-for-Artificial-Intelligence-Bratko",
            "title": {
                "fragments": [],
                "text": "Prolog Programming for Artificial Intelligence"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1986
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1694780"
                        ],
                        "name": "M. Pazzani",
                        "slug": "M.-Pazzani",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Pazzani",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Pazzani"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3202382"
                        ],
                        "name": "Clifford Brunk",
                        "slug": "Clifford-Brunk",
                        "structuredName": {
                            "firstName": "Clifford",
                            "lastName": "Brunk",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Clifford Brunk"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "48777826"
                        ],
                        "name": "G. Silverstein",
                        "slug": "G.-Silverstein",
                        "structuredName": {
                            "firstName": "Glenn",
                            "lastName": "Silverstein",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Silverstein"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 39450890,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "bfcbc389a6df12d5f42d86068a780b31e64f336b",
            "isKey": false,
            "numCitedBy": 100,
            "numCiting": 4,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "A-Knowledge-intensive-Approach-to-Learning-Concepts-Pazzani-Brunk",
            "title": {
                "fragments": [],
                "text": "A Knowledge-intensive Approach to Learning Relational Concepts"
            },
            "venue": {
                "fragments": [],
                "text": "ML"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145147566"
                        ],
                        "name": "S. Muggleton",
                        "slug": "S.-Muggleton",
                        "structuredName": {
                            "firstName": "Stephen",
                            "lastName": "Muggleton",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Muggleton"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2117343701"
                        ],
                        "name": "C. Feng",
                        "slug": "C.-Feng",
                        "structuredName": {
                            "firstName": "Cao",
                            "lastName": "Feng",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Feng"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 127,
                                "start": 103
                            }
                        ],
                        "text": "This is the key insight underlying determinate literals, an idea inspired by GOLEM's determinate terms Muggleton and Feng, 1990] : the value of each new variable is forced or determined by the values of existing variables."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 14992676,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "6a669636e0ada62a0fb444e95435e24fdbdf4dbd",
            "isKey": false,
            "numCitedBy": 848,
            "numCiting": 11,
            "paperAbstract": {
                "fragments": [],
                "text": "Recently there has been increasing interest in systems which induce rst order logic programs from examples. However, many diiculties need to be overcome. Well-known algorithms fail to discover correct logical descriptions for large classes of interesting predicates , due either to the intractability of search or overly strong limitations applied to the hypothesis space. In contrast, search is avoided within Plotkin's framework of relative least general generalisation (rlgg). It is replaced by the process of constructing a unique clause which covers a set of examples relative to given background knowledge. However, such a clause can in the worst case contain innnitely many literals, or at best grow exponentially with the number of examples involved. In this paper we introduce the concept of h-easy rlgg clauses and show that they have nite length. We also prove that the length of a certain class of \\determinate\" rlgg is bounded by a polynomial function of certain features of the background knowledge. This function is independent of the number of examples used to construct them. An existing implementation called GOLEM is shown to be capable of inducing many interesting logic programs which have not been demonstrated to be learnable using other algorithms."
            },
            "slug": "Efficient-Induction-of-Logic-Programs-Muggleton-Feng",
            "title": {
                "fragments": [],
                "text": "Efficient Induction of Logic Programs"
            },
            "tldr": {
                "abstractSimilarityScore": 39,
                "text": "The concept of h-easy rlgg clauses is introduced and it is proved that the length of a certain class of \\determinate\" r lgg is bounded by a polynomial function of certain features of the background knowledge."
            },
            "venue": {
                "fragments": [],
                "text": "ALT"
            },
            "year": 1990
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145341779"
                        ],
                        "name": "J. R. Quinlan",
                        "slug": "J.-R.-Quinlan",
                        "structuredName": {
                            "firstName": "J.",
                            "lastName": "Quinlan",
                            "middleNames": [
                                "Ross"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. R. Quinlan"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 5262555,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "807c1f19047f96083e13614f7ce20f2ac98c239a",
            "isKey": false,
            "numCitedBy": 21899,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "From the Publisher: \nClassifier systems play a major role in machine learning and knowledge-based systems, and Ross Quinlan's work on ID3 and C4.5 is widely acknowledged to have made some of the most significant contributions to their development. This book is a complete guide to the C4.5 system as implemented in C for the UNIX environment. It contains a comprehensive guide to the system's use , the source code (about 8,800 lines), and implementation notes. The source code and sample datasets are also available on a 3.5-inch floppy diskette for a Sun workstation. \n \nC4.5 starts with large sets of cases belonging to known classes. The cases, described by any mixture of nominal and numeric properties, are scrutinized for patterns that allow the classes to be reliably discriminated. These patterns are then expressed as models, in the form of decision trees or sets of if-then rules, that can be used to classify new cases, with emphasis on making the models understandable as well as accurate. The system has been applied successfully to tasks involving tens of thousands of cases described by hundreds of properties. The book starts from simple core learning methods and shows how they can be elaborated and extended to deal with typical problems such as missing data and over hitting. Advantages and disadvantages of the C4.5 approach are discussed and illustrated with several case studies. \n \nThis book and software should be of interest to developers of classification-based intelligent systems and to students in machine learning and expert systems courses."
            },
            "slug": "C4.5:-Programs-for-Machine-Learning-Quinlan",
            "title": {
                "fragments": [],
                "text": "C4.5: Programs for Machine Learning"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "A complete guide to the C4.5 system as implemented in C for the UNIX environment, which starts from simple core learning methods and shows how they can be elaborated and extended to deal with typical problems such as missing data and over hitting."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1992
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143752440"
                        ],
                        "name": "E. Shapiro",
                        "slug": "E.-Shapiro",
                        "structuredName": {
                            "firstName": "Ehud",
                            "lastName": "Shapiro",
                            "middleNames": [
                                "Y."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. Shapiro"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 60699326,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "3e36f22685b8d3db73532d3104b325cea5288a66",
            "isKey": false,
            "numCitedBy": 1280,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "The thesis lays a theoretical framework for program debugging, with the goal of partly mechanizing this activity. In particular, we formalize and develop algorithmic solutions to the following two questions: (1) How do we identify a bug in a program that behaves incorrectly? (2) How do we fix a bug, once one is identified? \nWe develop interactive diagnosis algorithms that identify a bug in a program that behaves incorrectly, and implement them in Prolog for the diagnosis of Prolog programs. Their performance suggests that they can be the backbone of debugging aids that go far beyond what is offered by current programming environments. \nWe develop an inductive inference algorithm that synthesizes logic programs from examples of their behavior. The algorithm incorporates the diagnosis algorithms as a component. It is incremental, and progresses by debugging a program with respect to the examples. The Model Inference System is a Prolog implementation of the algorithm. Its range of applications and efficiency is comparable to existing systems for program synthesis from examples and grammatical inference. \nWe develop an algorithm that can fix a bug that has been identified, and integrate it with the diagnosis algorithms to form an interactive debugging system. By restricting the class of bugs we attempt to correct, the system can debug programs that are too complex for the Model Inference System to synthesize."
            },
            "slug": "Algorithmic-Program-Debugging-Shapiro",
            "title": {
                "fragments": [],
                "text": "Algorithmic Program Debugging"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "An algorithm that can fix a bug that has been identified, and integrate it with the diagnosis algorithms to form an interactive debugging system that can debug programs that are too complex for the Model Inference System to synthesize."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1983
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "48323507"
                        ],
                        "name": "Peter Clark",
                        "slug": "Peter-Clark",
                        "structuredName": {
                            "firstName": "Peter",
                            "lastName": "Clark",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Peter Clark"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2353436"
                        ],
                        "name": "T. Niblett",
                        "slug": "T.-Niblett",
                        "structuredName": {
                            "firstName": "Tim",
                            "lastName": "Niblett",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Niblett"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 13372054,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "56e97a7a4948ca18993eeedd4fb9aa89ba519c44",
            "isKey": false,
            "numCitedBy": 153,
            "numCiting": 38,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper examines the induction of classification rules from examples using real-world data. Real-world data is almost always characterized by two features, which are important for the design of an induction algorithm. Firstly, there is often noise present, for example, due to imperfect measuring equipment used to collect the data. Secondly the description language is often incomplete, such that examples with identical descriptions in the language will not always be members of the same class. Many induction systems make the \u2018noiseless domain\u2019 assumption that the examples do not contain errors and the description language is complete, and consequently constrain their search for rules to those for which no counterexamples exist in the data used for induction. However, in real-world domains correlations between attributes and classes in a data set are rarely without exceptions. To locate such correlations and induce rules describing them it is also necessary to consider rules which may not classify all the training examples correctly. This paper firstly discusses some of the problems presented by noise and proposes a top-down induction algorithm for induction in real-world domains. Secondly, an experimental comparison of this algorithm with other induction systems is presented using three sets of real-world medical data."
            },
            "slug": "Induction-in-Noisy-Domains-Clark-Niblett",
            "title": {
                "fragments": [],
                "text": "Induction in Noisy Domains"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "Some of the problems presented by noise are discussed and a top-down induction algorithm for induction in real-world domains is proposed and an experimental comparison of this algorithm with other induction systems is presented using three sets of real- world medical data."
            },
            "venue": {
                "fragments": [],
                "text": "EWSL"
            },
            "year": 1987
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2421006"
                        ],
                        "name": "R. Michalski",
                        "slug": "R.-Michalski",
                        "structuredName": {
                            "firstName": "Ryszard",
                            "lastName": "Michalski",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Michalski"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1715207"
                        ],
                        "name": "I. Mozetic",
                        "slug": "I.-Mozetic",
                        "structuredName": {
                            "firstName": "Igor",
                            "lastName": "Mozetic",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "I. Mozetic"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1906321"
                        ],
                        "name": "J. Hong",
                        "slug": "J.-Hong",
                        "structuredName": {
                            "firstName": "Jiarong",
                            "lastName": "Hong",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Hong"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1730104"
                        ],
                        "name": "N. Lavrac",
                        "slug": "N.-Lavrac",
                        "structuredName": {
                            "firstName": "Nada",
                            "lastName": "Lavrac",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Lavrac"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 18018701,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "879a760cd5fcc1de36422afbcdd05bd73ba0ee4f",
            "isKey": false,
            "numCitedBy": 957,
            "numCiting": 24,
            "paperAbstract": {
                "fragments": [],
                "text": "AQ15 is a multi-purpose inductive learning system that uses logic-based, user-oriented knowledge representation, is able to incrementally learn disjunctive concepts from noisy or overlapping examples, and can perform constructive induction (i.e., can generate new attributes in the process of learning). In an experimental application to three medical domains, the program learned decision rules that performed at the level of accuracy of human experts. A surprising and potentially significant result is the demonstration that by applying the proposed method of cover truncation and analogical matching, called TRUNC, one may drastically decrease the complexity of the knowledge base without affecting its performance accuracy."
            },
            "slug": "The-Multi-Purpose-Incremental-Learning-System-AQ15-Michalski-Mozetic",
            "title": {
                "fragments": [],
                "text": "The Multi-Purpose Incremental Learning System AQ15 and Its Testing Application to Three Medical Domains"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "The demonstration that by applying the proposed method of cover truncation and analogical matching, called TRUNC, one may drastically decrease the complexity of the knowledge base without affecting its performance accuracy is demonstrated."
            },
            "venue": {
                "fragments": [],
                "text": "AAAI"
            },
            "year": 1986
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2321708"
                        ],
                        "name": "C. Rouveirol",
                        "slug": "C.-Rouveirol",
                        "structuredName": {
                            "firstName": "C\u00e9line",
                            "lastName": "Rouveirol",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Rouveirol"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 28862233,
            "fieldsOfStudy": [
                "Mathematics",
                "Philosophy",
                "Computer Science"
            ],
            "id": "8ebae3a4397cbfa78cd9956336e0942f433a5842",
            "isKey": false,
            "numCitedBy": 13,
            "numCiting": 5,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Completeness-for-Inductive-Procedures-Rouveirol",
            "title": {
                "fragments": [],
                "text": "Completeness for Inductive Procedures"
            },
            "venue": {
                "fragments": [],
                "text": "ML"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "40481777"
                        ],
                        "name": "E. Hunt",
                        "slug": "E.-Hunt",
                        "structuredName": {
                            "firstName": "E.",
                            "lastName": "Hunt",
                            "middleNames": [
                                "B."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. Hunt"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 64164169,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "01fe9f988dae545d2b588e8bb8a4a25992d702ed",
            "isKey": false,
            "numCitedBy": 36,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Machine-learning:-An-artificial-intelligence-(vol.-Hunt",
            "title": {
                "fragments": [],
                "text": "Machine learning: An artificial intelligence approach (vol. 2): R. S. Michalski, J. G. Carbonell, and T. M. Mitchell (Eds.). Los Alton, CA: Morgan Kaufmann, 1986. Pp. x + 738. $39.95"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1987
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2476128"
                        ],
                        "name": "B. Cestnik",
                        "slug": "B.-Cestnik",
                        "structuredName": {
                            "firstName": "Bojan",
                            "lastName": "Cestnik",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Cestnik"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143986204"
                        ],
                        "name": "I. Kononenko",
                        "slug": "I.-Kononenko",
                        "structuredName": {
                            "firstName": "Igor",
                            "lastName": "Kononenko",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "I. Kononenko"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1725040"
                        ],
                        "name": "I. Bratko",
                        "slug": "I.-Bratko",
                        "structuredName": {
                            "firstName": "Ivan",
                            "lastName": "Bratko",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "I. Bratko"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 39569406,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "22ffbb97b6a55603bc0bccda60ac3b2ef5427153",
            "isKey": false,
            "numCitedBy": 528,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "ASSISTANT-86:-A-Knowledge-Elicitation-Tool-for-Cestnik-Kononenko",
            "title": {
                "fragments": [],
                "text": "ASSISTANT 86: A Knowledge-Elicitation Tool for Sophisticated Users"
            },
            "venue": {
                "fragments": [],
                "text": "EWSL"
            },
            "year": 1987
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Classiication and Regression Trees"
            },
            "venue": {
                "fragments": [],
                "text": "Classiication and Regression Trees"
            },
            "year": 1984
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 17,
                                "start": 4
                            }
                        ],
                        "text": "See Quinlan, 1990] for details."
                    },
                    "intents": []
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Learning logical deenitions from relations"
            },
            "venue": {
                "fragments": [],
                "text": "Machine Learning"
            },
            "year": 1990
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 151,
                                "start": 139
                            }
                        ],
                        "text": "As a step towards a more pragmatic evaluation, we started with Ivan Bratko's well-known text Prolog Programming for Artiicial Intelligence Bratko, 1986]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Prolog Programming for Artiicial Intelligence"
            },
            "venue": {
                "fragments": [],
                "text": "Prolog Programming for Artiicial Intelligence"
            },
            "year": 1986
        }
    ],
    "meta_info": {
        "citationIntent": "all",
        "citationIntentCount": {
            "background": 2,
            "methodology": 2
        },
        "citationType": "citedPapers",
        "pageNumber": 1,
        "requestedPageSize": 10,
        "sort": "relevance",
        "totalCitations": 18,
        "totalPages": 2
    },
    "page_url": "https://www.semanticscholar.org/paper/FOIL:-A-Midterm-Report-Quinlan-Cameron-Jones/f2cf9ae81b38f7637899f19274226e623f9b153b?sort=total-citations"
}
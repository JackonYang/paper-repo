{
    "links": [
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2516166"
                        ],
                        "name": "J. Rissanen",
                        "slug": "J.-Rissanen",
                        "structuredName": {
                            "firstName": "Jorma",
                            "lastName": "Rissanen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Rissanen"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 16011297,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "9fcb8d85e3d429f3816861fc7999e1bb68eefd39",
            "isKey": false,
            "numCitedBy": 569,
            "numCiting": 7,
            "paperAbstract": {
                "fragments": [],
                "text": "Algorithms for encoding and decoding finite strings over a finite alphabet are described. The coding operations are arithmetic involving rational numbers li as parameters such that \u03a3i2-l i\u22642-\u2208. This coding technique requires no blocking, and the per-symbol length of the encoded string approaches the associated entropy within \u2208. The coding speed is comparable to that of conventional coding methods."
            },
            "slug": "Generalized-Kraft-Inequality-and-Arithmetic-Coding-Rissanen",
            "title": {
                "fragments": [],
                "text": "Generalized Kraft Inequality and Arithmetic Coding"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "This coding technique requires no blocking, and the per-symbol length of the encoded string approaches the associated entropy within \u2208, which is comparable to that of conventional coding methods."
            },
            "venue": {
                "fragments": [],
                "text": "IBM J. Res. Dev."
            },
            "year": 1976
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2040420"
                        ],
                        "name": "F. Rubin",
                        "slug": "F.-Rubin",
                        "structuredName": {
                            "firstName": "Frank",
                            "lastName": "Rubin",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Rubin"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 35964389,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "47d1350e9d5b637a7fc888b52c5b9291985b9ed8",
            "isKey": false,
            "numCitedBy": 112,
            "numCiting": 2,
            "paperAbstract": {
                "fragments": [],
                "text": "Algorithms are presented for encoding and decoding strings of characters as real binary fractions, using registers of fixed precision. The encoding is left to right and does not require blocking. The algorithms have storage requirements O(N) and computation time O(n \\log_{2}N) for string length n and alphabet size N ."
            },
            "slug": "Arithmetic-stream-coding-using-fixed-precision-Rubin",
            "title": {
                "fragments": [],
                "text": "Arithmetic stream coding using fixed precision registers"
            },
            "tldr": {
                "abstractSimilarityScore": 75,
                "text": "Algorithms are presented for encoding and decoding strings of characters as real binary fractions, using registers of fixed precision, and have storage requirements and computation time O(n \\log_{2}N) for string length n and alphabet size N."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Inf. Theory"
            },
            "year": 1979
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144369308"
                        ],
                        "name": "J. Schalkwijk",
                        "slug": "J.-Schalkwijk",
                        "structuredName": {
                            "firstName": "J.",
                            "lastName": "Schalkwijk",
                            "middleNames": [
                                "Pieter",
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Schalkwijk"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 12594686,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "966a4b2f96090a1044eda1ae271c3f94ed704380",
            "isKey": false,
            "numCitedBy": 153,
            "numCiting": 2,
            "paperAbstract": {
                "fragments": [],
                "text": "We derive a simple algorithm for the ranking of binary sequences of length n and weight w . This algorithm is then used for source encoding a memoryless binary source that generates O's with probability q and l's with probability p = 1 - q ."
            },
            "slug": "An-algorithm-for-source-coding-Schalkwijk",
            "title": {
                "fragments": [],
                "text": "An algorithm for source coding"
            },
            "tldr": {
                "abstractSimilarityScore": 89,
                "text": "This work derives a simple algorithm for the ranking of binary sequences of length n and weight w and uses it for source encoding a memoryless binary source that generates O's and l's with probability p = 1 - q."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Inf. Theory"
            },
            "year": 1972
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145720405"
                        ],
                        "name": "J. Ziv",
                        "slug": "J.-Ziv",
                        "structuredName": {
                            "firstName": "Jacob",
                            "lastName": "Ziv",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Ziv"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "50154247"
                        ],
                        "name": "A. Lempel",
                        "slug": "A.-Lempel",
                        "structuredName": {
                            "firstName": "Abraham",
                            "lastName": "Lempel",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Lempel"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 9267632,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "59c9f2036e673d8bc9713eed851d12c6c9fe53cb",
            "isKey": false,
            "numCitedBy": 5369,
            "numCiting": 17,
            "paperAbstract": {
                "fragments": [],
                "text": "A universal algorithm for sequential data compression is presented. Its performance is investigated with respect to a nonprobabilistic model of constrained sources. The compression ratio achieved by the proposed universal code uniformly approaches the lower bounds on the compression ratios attainable by block-to-variable codes and variable-to-block codes designed to match a completely specified source."
            },
            "slug": "A-universal-algorithm-for-sequential-data-Ziv-Lempel",
            "title": {
                "fragments": [],
                "text": "A universal algorithm for sequential data compression"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "The compression ratio achieved by the proposed universal code uniformly approaches the lower bounds on the compression ratios attainable by block-to-variable codes and variable- to-block codes designed to match a completely specified source."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Inf. Theory"
            },
            "year": 1977
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2690359"
                        ],
                        "name": "D. Huffman",
                        "slug": "D.-Huffman",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Huffman",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Huffman"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 10606404,
            "fieldsOfStudy": [
                "Computer Science",
                "Business"
            ],
            "id": "a068df4c5f829bd0b85bf72fd919006c563c6345",
            "isKey": false,
            "numCitedBy": 4112,
            "numCiting": 3,
            "paperAbstract": {
                "fragments": [],
                "text": "SummaryAn optimum method of coding an ensemble of messages consisting of a finite number of members is developed. A minimum-redundancy code is one constructed in such a way that the average number of coding digits per message is minimized."
            },
            "slug": "A-method-for-the-construction-of-minimum-redundancy-Huffman",
            "title": {
                "fragments": [],
                "text": "A method for the construction of minimum-redundancy codes"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "A minimum-redundancy code is one constructed in such a way that the average number of coding digits per message is minimized."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of the IRE"
            },
            "year": 1952
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3231060"
                        ],
                        "name": "M. Guazzo",
                        "slug": "M.-Guazzo",
                        "structuredName": {
                            "firstName": "Mauro",
                            "lastName": "Guazzo",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Guazzo"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 45795043,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "dbfdbec08d67349e364898f6c6ab289c06e00460",
            "isKey": false,
            "numCitedBy": 73,
            "numCiting": 9,
            "paperAbstract": {
                "fragments": [],
                "text": "An algorithm for the minimum-redundancy encoding of a discrete information source is proposed. In the case of memoryless sources it is shown that the theoretical compression can be appmached within any desired threshold without the burden of alphabet extensions (i.e., the encodhg of blocks of L primary symbols) and also irrespective of 1) the primary and secondary alphabet sizes 2) the numerical values of primary symbol probabillties, and 3) the order and structure of the encoding tree. The same algorithm is then extended to sources with memory and to cases in which there is a constraint on the statistical description of the secondary sequence (e.g., secondary symbol probabilities are given). The technique can thus be used to transform any given discrete source into any other given discrete source while minimizing the ratio of average secondary sequence length to average primary sequence length."
            },
            "slug": "A-general-minimum-redundancy-source-coding-Guazzo",
            "title": {
                "fragments": [],
                "text": "A general minimum-redundancy source-coding algorithm"
            },
            "tldr": {
                "abstractSimilarityScore": 86,
                "text": "An algorithm for the minimum-redundancy encoding of a discrete information source is proposed and it is shown that the theoretical compression can be appmached within any desired threshold without the burden of alphabet extensions."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Inf. Theory"
            },
            "year": 1980
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1737968"
                        ],
                        "name": "E. Gilbert",
                        "slug": "E.-Gilbert",
                        "structuredName": {
                            "firstName": "Edgar",
                            "lastName": "Gilbert",
                            "middleNames": [
                                "N."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. Gilbert"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "34166566"
                        ],
                        "name": "E. F. Moore",
                        "slug": "E.-F.-Moore",
                        "structuredName": {
                            "firstName": "Edward",
                            "lastName": "Moore",
                            "middleNames": [
                                "F."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. F. Moore"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 122838872,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "9c7376d1e65bf498aadf7c288b86a84ba2734d68",
            "isKey": false,
            "numCitedBy": 355,
            "numCiting": 3,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper gives a theoretical treatment of several properties which describe certain variable-length binary encodings of the sort which could be used for the storage or transmission of information. Some of these, such as the prefix and finite delay properties, deal with the time delay with which circuits can be built to decipher the encodings. The self-synchronizing property deals with the ability of the deciphering circuits to get in phase automatically with the enciphering circuits. Exhaustive encodings have the property that all possible sequences of binary digits can occur as messages. Alphabetical-order encodings are those for which the alphabetical order of the letters is preserved as the numerical order of the binary codes, and would be of possible value for sorting of data or consultation of files or dictionaries. Various theorems are proved about the relationships between these properties, and also about their relationship to the average number of binary digits used to encode each letter of the original message."
            },
            "slug": "Variable-length-binary-encodings-Gilbert-Moore",
            "title": {
                "fragments": [],
                "text": "Variable-length binary encodings"
            },
            "tldr": {
                "abstractSimilarityScore": 95,
                "text": "This paper gives a theoretical treatment of several properties which describe certain variable-length binary encodings of the sort which could be used for the storage or transmission of information, such as the prefix and finite delay properties."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1959
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145720405"
                        ],
                        "name": "J. Ziv",
                        "slug": "J.-Ziv",
                        "structuredName": {
                            "firstName": "Jacob",
                            "lastName": "Ziv",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Ziv"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "50154247"
                        ],
                        "name": "A. Lempel",
                        "slug": "A.-Lempel",
                        "structuredName": {
                            "firstName": "Abraham",
                            "lastName": "Lempel",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Lempel"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 20900807,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "5be4e0eccca2892d31406a03b0c485f7a395fe5a",
            "isKey": false,
            "numCitedBy": 3487,
            "numCiting": 7,
            "paperAbstract": {
                "fragments": [],
                "text": "Compressibility of individual sequences by the class of generalized finite-state information-lossless encoders is investigated. These encoders can operate in a variable-rate mode as well as a fixed-rate one, and they allow for any finite-state scheme of variable-length-to-variable-length coding. For every individual infinite sequence x a quantity \\rho(x) is defined, called the compressibility of x , which is shown to be the asymptotically attainable lower bound on the compression ratio that can be achieved for x by any finite-state encoder. This is demonstrated by means of a constructive coding theorem and its converse that, apart from their asymptotic significance, also provide useful performance criteria for finite and practical data-compression tasks. The proposed concept of compressibility is also shown to play a role analogous to that of entropy in classical information theory where one deals with probabilistic ensembles of sequences rather than with individual sequences. While the definition of \\rho(x) allows a different machine for each different sequence to be compressed, the constructive coding theorem leads to a universal algorithm that is asymptotically optimal for all sequences."
            },
            "slug": "Compression-of-individual-sequences-via-coding-Ziv-Lempel",
            "title": {
                "fragments": [],
                "text": "Compression of individual sequences via variable-rate coding"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "The proposed concept of compressibility is shown to play a role analogous to that of entropy in classical information theory where one deals with probabilistic ensembles of sequences rather than with individual sequences."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Inf. Theory"
            },
            "year": 1978
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1770859"
                        ],
                        "name": "R. Gallager",
                        "slug": "R.-Gallager",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "Gallager",
                            "middleNames": [
                                "G."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Gallager"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 2033521,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "65e6ef044d951d2c3cbf7512b6bfa83a8b2b0739",
            "isKey": false,
            "numCitedBy": 579,
            "numCiting": 2,
            "paperAbstract": {
                "fragments": [],
                "text": "In honor of the twenty-fifth anniversary of Huffman coding, four new results about Huffman codes are presented. The first result shows that a binary prefix condition code is a Huffman code iff the intermediate and terminal nodes in the code tree can be listed by nonincreasing probability so that each node in the list is adjacent to its sibling. The second result upper bounds the redundancy (expected length minus entropy) of a binary Huffman code by P_{1}+ \\log_{2}[2(\\log_{2}e)/e]=P_{1}+0.086 , where P_{1} is the probability of the most likely source letter. The third result shows that one can always leave a codeword of length two unused and still have a redundancy of at most one. The fourth result is a simple algorithm for adapting a Huffman code to slowly varying esthnates of the source probabilities. In essence, one maintains a running count of uses of each node in the code tree and lists the nodes in order of these counts. Whenever the occurrence of a message increases a node count above the count of the next node in the list, the nodes, with their attached subtrees, are interchanged."
            },
            "slug": "Variations-on-a-theme-by-Huffman-Gallager",
            "title": {
                "fragments": [],
                "text": "Variations on a theme by Huffman"
            },
            "tldr": {
                "abstractSimilarityScore": 47,
                "text": "Four new results about Huffman codes are presented and a simple algorithm for adapting a Huffman code to slowly varying esthnates of the source probabilities is presented."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Inf. Theory"
            },
            "year": 1978
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1752732"
                        ],
                        "name": "T. Cover",
                        "slug": "T.-Cover",
                        "structuredName": {
                            "firstName": "Thomas",
                            "lastName": "Cover",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Cover"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 29318491,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "4289cb1f5a86232df0edd3b29d139e18239196ee",
            "isKey": false,
            "numCitedBy": 441,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "Let S be a given subset of binary n-sequences. We provide an explicit scheme for calculating the index of any sequence in S according to its position in the lexicographic ordering of S . A simple inverse algorithm is also given. Particularly nice formulas arise when S is the set of all n -sequences of weight k and also when S is the set of all sequences having a given empirical Markov property. Schalkwijk and Lynch have investigated the former case. The envisioned use of this indexing scheme is to transmit or store the index rather than the sequence, thus resulting in a data compression of (\\log\\midS\\mid)/n ."
            },
            "slug": "Enumerative-source-encoding-Cover",
            "title": {
                "fragments": [],
                "text": "Enumerative source encoding"
            },
            "tldr": {
                "abstractSimilarityScore": 76,
                "text": "This work provides an explicit scheme for calculating the index of any sequence in S according to its position in the lexicographic ordering of S, thus resulting in a data compression of (log\\midS\\mid)/n."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Inf. Theory"
            },
            "year": 1973
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "69548824"
                        ],
                        "name": "S. Golomb",
                        "slug": "S.-Golomb",
                        "structuredName": {
                            "firstName": "Solomon",
                            "lastName": "Golomb",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Golomb"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 206728952,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "03dc759f8dec25d22086afa34970e984eddb5418",
            "isKey": false,
            "numCitedBy": 720,
            "numCiting": 4,
            "paperAbstract": {
                "fragments": [],
                "text": "explicitly evaluable functions. For example, the M-ary error probability is expressed as a quadrature in Lindsey's equation (17), PE(M) = 1 [I-2 lrn Qi(h, $;) exp (-g) dz] z/d eeL s m =22/;;moe-(1+d)s~41-'2@3(1, 1 + M, s, sL) d.s, (5) where, following Lindsey, h2/2 has been replaced by L to simplify the notation. From the series form of @3, it is obvious that the integral gives an additional double series numerator parameter: PE(M) = di eeL z ~1 (1 + d)-\"-1'2 i (61 A complete set of recursion relations for F1 when one parameter at a time changes has been given by Le Vavasseur [S]. It is a simple matter to derive the necessary change for this two-parameter case but Le Vavasseur has included this as one of several examples, so that we have at once (8) (9)-I, e (a \"-' a \" '-'_ [eLP,(l)] = (1 + &)Y,(l), which is equivalent to a result of Price [9], who has derived a number of expressions for these and related integrals. Note that the derivation above is, thus far, much simpler and more straightforward than the admirably executed tours de force of previous derivations. However, the last step, viz., recognizing the form of the result, is automatically accomplished in the other derivations, and is much the harder part in the hypergeometric case. To obtain the reduction, we use operational relations [lo] to get The integral with the special parameters of (11) has been previously recognized as a Q function [12]-[14] so that the reduction is essentially complete."
            },
            "slug": "Run-length-encodings-(Corresp.)-Golomb",
            "title": {
                "fragments": [],
                "text": "Run-length encodings (Corresp.)"
            },
            "tldr": {
                "abstractSimilarityScore": 37,
                "text": "To obtain the reduction, the authors use operational relations [lo] to get The integral with the special parameters of (11) has been previously recognized as a Q function [12]-[14] so that the reduction is essentially complete."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Inf. Theory"
            },
            "year": 1966
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1717349"
                        ],
                        "name": "D. Knuth",
                        "slug": "D.-Knuth",
                        "structuredName": {
                            "firstName": "Donald",
                            "lastName": "Knuth",
                            "middleNames": [
                                "Ervin"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Knuth"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 65140997,
            "fieldsOfStudy": [
                "Engineering",
                "Physics"
            ],
            "id": "748f27587c37d8b0882a20692967901b81429fce",
            "isKey": false,
            "numCitedBy": 11594,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "A fuel pin hold-down and spacing apparatus for use in nuclear reactors is disclosed. Fuel pins forming a hexagonal array are spaced apart from each other and held-down at their lower end, securely attached at two places along their length to one of a plurality of vertically disposed parallel plates arranged in horizontally spaced rows. These plates are in turn spaced apart from each other and held together by a combination of spacing and fastening means. The arrangement of this invention provides a strong vibration free hold-down mechanism while avoiding a large pressure drop to the flow of coolant fluid. This apparatus is particularly useful in connection with liquid cooled reactors such as liquid metal cooled fast breeder reactors."
            },
            "slug": "The-Art-of-Computer-Programming-Knuth",
            "title": {
                "fragments": [],
                "text": "The Art of Computer Programming"
            },
            "tldr": {
                "abstractSimilarityScore": 38,
                "text": "The arrangement of this invention provides a strong vibration free hold-down mechanism while avoiding a large pressure drop to the flow of coolant fluid."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1968
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "31941627"
                        ],
                        "name": "N. Abramson",
                        "slug": "N.-Abramson",
                        "structuredName": {
                            "firstName": "Norman",
                            "lastName": "Abramson",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Abramson"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 122474563,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "d2f93dc1bebd82b55fb3322f9d323d5b3a69521b",
            "isKey": false,
            "numCitedBy": 537,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Information-theory-and-coding-Abramson",
            "title": {
                "fragments": [],
                "text": "Information theory and coding"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1963
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2126645"
                        ],
                        "name": "Richard C. Pasco",
                        "slug": "Richard-C.-Pasco",
                        "structuredName": {
                            "firstName": "Richard",
                            "lastName": "Pasco",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Richard C. Pasco"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 60531818,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "6e9a6af4bc23b4cd139e671f4d1b2ca18228f660",
            "isKey": false,
            "numCitedBy": 229,
            "numCiting": 21,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Source-coding-algorithms-for-fast-data-compression-Pasco",
            "title": {
                "fragments": [],
                "text": "Source coding algorithms for fast data compression"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1976
        }
    ],
    "meta_info": {
        "citationIntent": "all",
        "citationIntentCount": {},
        "citationType": "citedPapers",
        "pageNumber": 1,
        "requestedPageSize": 10,
        "sort": "relevance",
        "totalCitations": 14,
        "totalPages": 2
    },
    "page_url": "https://www.semanticscholar.org/paper/Arithmetic-Coding-Rissanen-Langdon/20d673dc3200ac1742ee0827535a291eb6e051f8?sort=total-citations"
}
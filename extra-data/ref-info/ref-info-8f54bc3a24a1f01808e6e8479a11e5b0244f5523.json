{
    "links": [
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2109260410"
                        ],
                        "name": "Cliff B. Jones",
                        "slug": "Cliff-B.-Jones",
                        "structuredName": {
                            "firstName": "Cliff",
                            "lastName": "Jones",
                            "middleNames": [
                                "B."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Cliff B. Jones"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 11803436,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "97be6bdd849b525569d76d8380af84d866260ba8",
            "isKey": false,
            "numCitedBy": 105,
            "numCiting": 11,
            "paperAbstract": {
                "fragments": [],
                "text": "The Elias source coding scheme is modified to permit a source sequence of practically unlimited length to be coded as a single codeword using arithmetic of only limited precision. The result is shown to be a nonblock arithmetic code of the first in, first out (FIFO) type-- source symbols are decoded in the same order as they were encoded. Codeword lengths which are near optimum for the specified statistical properties of the source can be achieved. Explicit encoding and decoding algorithms are Provided which effectively implement the coding scheme. Applications to data compression and cryptography are suggested."
            },
            "slug": "An-efficient-coding-system-for-long-source-Jones",
            "title": {
                "fragments": [],
                "text": "An efficient coding system for long source sequences"
            },
            "tldr": {
                "abstractSimilarityScore": 97,
                "text": "The Elias source coding scheme is modified to permit a source sequence of practically unlimited length to be coded as a single codeword using arithmetic of only limited precision, showing the result to be a nonblock arithmetic code of the first in, first out (FIFO) type."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Inf. Theory"
            },
            "year": 1981
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144251291"
                        ],
                        "name": "M. Schwartz",
                        "slug": "M.-Schwartz",
                        "structuredName": {
                            "firstName": "Mischa",
                            "lastName": "Schwartz",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Schwartz"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "33099490"
                        ],
                        "name": "W. Bennett",
                        "slug": "W.-Bennett",
                        "structuredName": {
                            "firstName": "W.",
                            "lastName": "Bennett",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Bennett"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2026271"
                        ],
                        "name": "S. Stein",
                        "slug": "S.-Stein",
                        "structuredName": {
                            "firstName": "Seymour",
                            "lastName": "Stein",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Stein"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "66020567"
                        ],
                        "name": "M. G. Pelchat",
                        "slug": "M.-G.-Pelchat",
                        "structuredName": {
                            "firstName": "M.",
                            "lastName": "Pelchat",
                            "middleNames": [
                                "G."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. G. Pelchat"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2059186965"
                        ],
                        "name": "S. Adams",
                        "slug": "S.-Adams",
                        "structuredName": {
                            "firstName": "S.",
                            "lastName": "Adams",
                            "middleNames": [
                                "L."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Adams"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 124962734,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "ba704372c6043d9e3c2a6a01ed52fac23662d567",
            "isKey": false,
            "numCitedBy": 112,
            "numCiting": 11,
            "paperAbstract": {
                "fragments": [],
                "text": "A new approach for black and white image compression is described, with which the eight CCITT test documents can be compressed in a lossless manner 20-30 percent better than with the best existing compression algorithms. The coding and the modeling aspects are treateil separately. The key to these improvements is an efficient binary, arithmetic code. The code is relatively simple to implement because it avoids the multiplication operation inherent in some earlier arithmetic codes. Arithmetic coding permits the com- pression of binary sequences where the statistics change on a bit-to-bit basis. Model statistics are studied from stationary, statiorary adaptive, and nonstationary adaptive assumptions."
            },
            "slug": "Compression-of-Black-White-Images-with-Arithmetic-Schwartz-Bennett",
            "title": {
                "fragments": [],
                "text": "Compression of Black-White Images with Arithmetic Coding"
            },
            "tldr": {
                "abstractSimilarityScore": 100,
                "text": "A new approach for black and white image compression is described, with which the eight CCITT test documents can be compressed in a lossless manner 20-30 percent better than with the best existing compression algorithms."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1981
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2107656585"
                        ],
                        "name": "G. Martin",
                        "slug": "G.-Martin",
                        "structuredName": {
                            "firstName": "G.",
                            "lastName": "Martin",
                            "middleNames": [
                                "Nigel"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Martin"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 17358601,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "3a46423f866d53d4e0328faf365c4c9101f82577",
            "isKey": false,
            "numCitedBy": 160,
            "numCiting": 8,
            "paperAbstract": {
                "fragments": [],
                "text": "Redundancy in a message can be thought of as consisting of contextual redundancy and alphabetic redundancy. The first is illustrated by the fact that the letter Q is nearly always followed by the letter U, the second by the fact that the letter E is far more common than the letter X. Range encoding is an algorithm for removing both sorts of redundancy. Since Huffman [1] published his paper in 1952 there has been a number of papers, e.g. [2], describing techniques for removing alphabetical redundancy, mostly generating prefix codes, and mostly transforming the messages into a bit string. The usual aim of such techniques is to reduce the quantity of storage required to hold a message. In the last fifteen years the growth of telemetry has increased interest in techniques for removing contextual redundancy. Many of these techniques approximate the message, rather than simply remove redundancy. Such techniques are often analog, and include transmitting the difference between a measured signal and a prediction of that measurement, or varying the rate at which a value is sampled according to the recent measurements of that value [3,4]. The output of such techniques may be a signal of generally low amplitude, or an intermittent signal ; the usual aim being to decrease the power consumed by a transmitter, or to reduce the risk of a circuit or recording medium being overloaded. Many techniques are almost optimal in a wide variety of situations, but none are universally applicable. In contrast, range encoding may be used to remove all the redundancy that we can describe in any digitised message. It can produce encodings to any base. Nomenclature We shall consider an uncoded or decoded message as a string of letters drawn from an alphabet, and an encoded message as a string of digits to a given base, thus it will be obvious whether we are talking about an encoded message or an uncoded one. We shall require the probability of a given letter occuring in any given context to be described by a frequency algorithm. We shall illustrate our algorithm by encoding and decoding a message composed of letters drawn from the alphabet {K,L,M,N}, and forming an encoded string of digits to base ten."
            },
            "slug": "*-Range-encoding:-an-algorithm-for-removing-from-a-Martin",
            "title": {
                "fragments": [],
                "text": "* Range encoding: an algorithm for removing redundancy from a digitised message"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "Range encoding is an algorithm for removing both sorts of redundancy in a message by encoding and decoding a message composed of letters drawn from the alphabet, and forming an encoded string of digits to base ten."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1979
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2516166"
                        ],
                        "name": "J. Rissanen",
                        "slug": "J.-Rissanen",
                        "structuredName": {
                            "firstName": "Jorma",
                            "lastName": "Rissanen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Rissanen"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 16011297,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "9fcb8d85e3d429f3816861fc7999e1bb68eefd39",
            "isKey": false,
            "numCitedBy": 569,
            "numCiting": 7,
            "paperAbstract": {
                "fragments": [],
                "text": "Algorithms for encoding and decoding finite strings over a finite alphabet are described. The coding operations are arithmetic involving rational numbers li as parameters such that \u03a3i2-l i\u22642-\u2208. This coding technique requires no blocking, and the per-symbol length of the encoded string approaches the associated entropy within \u2208. The coding speed is comparable to that of conventional coding methods."
            },
            "slug": "Generalized-Kraft-Inequality-and-Arithmetic-Coding-Rissanen",
            "title": {
                "fragments": [],
                "text": "Generalized Kraft Inequality and Arithmetic Coding"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "This coding technique requires no blocking, and the per-symbol length of the encoded string approaches the associated entropy within \u2208, which is comparable to that of conventional coding methods."
            },
            "venue": {
                "fragments": [],
                "text": "IBM J. Res. Dev."
            },
            "year": 1976
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1752732"
                        ],
                        "name": "T. Cover",
                        "slug": "T.-Cover",
                        "structuredName": {
                            "firstName": "Thomas",
                            "lastName": "Cover",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Cover"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 29318491,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "4289cb1f5a86232df0edd3b29d139e18239196ee",
            "isKey": false,
            "numCitedBy": 441,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "Let S be a given subset of binary n-sequences. We provide an explicit scheme for calculating the index of any sequence in S according to its position in the lexicographic ordering of S . A simple inverse algorithm is also given. Particularly nice formulas arise when S is the set of all n -sequences of weight k and also when S is the set of all sequences having a given empirical Markov property. Schalkwijk and Lynch have investigated the former case. The envisioned use of this indexing scheme is to transmit or store the index rather than the sequence, thus resulting in a data compression of (\\log\\midS\\mid)/n ."
            },
            "slug": "Enumerative-source-encoding-Cover",
            "title": {
                "fragments": [],
                "text": "Enumerative source encoding"
            },
            "tldr": {
                "abstractSimilarityScore": 76,
                "text": "This work provides an explicit scheme for calculating the index of any sequence in S according to its position in the lexicographic ordering of S, thus resulting in a data compression of (log\\midS\\mid)/n."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Inf. Theory"
            },
            "year": 1973
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2516166"
                        ],
                        "name": "J. Rissanen",
                        "slug": "J.-Rissanen",
                        "structuredName": {
                            "firstName": "Jorma",
                            "lastName": "Rissanen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Rissanen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3337260"
                        ],
                        "name": "G. Langdon",
                        "slug": "G.-Langdon",
                        "structuredName": {
                            "firstName": "Glen",
                            "lastName": "Langdon",
                            "middleNames": [
                                "G."
                            ],
                            "suffix": "Jr."
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Langdon"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 39909636,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "20d673dc3200ac1742ee0827535a291eb6e051f8",
            "isKey": false,
            "numCitedBy": 759,
            "numCiting": 14,
            "paperAbstract": {
                "fragments": [],
                "text": "The earlier introduced arithmetic coding idea has been generalized to a very broad and flexible coding technique which includes virtually all known variable rate noiseless coding techniques as special cases. An outstanding feature of this technique is that alphabet extensions are not required. A complete decodability analysis is given. The relationship of arithmetic coding to other known nonblock codes is illuminated."
            },
            "slug": "Arithmetic-Coding-Rissanen-Langdon",
            "title": {
                "fragments": [],
                "text": "Arithmetic Coding"
            },
            "tldr": {
                "abstractSimilarityScore": 100,
                "text": "The earlier introduced arithmetic coding idea has been generalized to a very broad and flexible coding technique which includes virtually all known variable rate noiseless coding techniques as special cases."
            },
            "venue": {
                "fragments": [],
                "text": "IBM J. Res. Dev."
            },
            "year": 1979
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1402910087"
                        ],
                        "name": "S. K. Leung-Yan-Cheong",
                        "slug": "S.-K.-Leung-Yan-Cheong",
                        "structuredName": {
                            "firstName": "Sik",
                            "lastName": "Leung-Yan-Cheong",
                            "middleNames": [
                                "K."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. K. Leung-Yan-Cheong"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1752732"
                        ],
                        "name": "T. Cover",
                        "slug": "T.-Cover",
                        "structuredName": {
                            "firstName": "Thomas",
                            "lastName": "Cover",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Cover"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 7970875,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "c6aece82c4c2076eb22db65a16e6c376b94df37b",
            "isKey": false,
            "numCitedBy": 116,
            "numCiting": 6,
            "paperAbstract": {
                "fragments": [],
                "text": "It is known that the expected codeword length L_{UD} of the best uniquely decodable (UD) code satisfies H(X)\\leqL_{UD} . Let X be a random variable which can take on n values. Then it is shown that the average codeword length L_{1:1} for the best one-to-one (not necessarily uniquely decodable) code for X is shorter than the average codeword length L_{UD} for the best uniquely decodable code by no more than (\\log_{2} \\log_{2} n)+ 3 . Let Y be a random variable taking on a finite or countable number of values and having entropy H . Then it is proved that L_{1:1}\\geq H-\\log_{2}(H + 1)-\\log_{2}\\log_{2}(H + 1 )-\\cdots -6 . Some relations are established among the Kolmogorov, Chaitin, and extension complexities. Finally it is shown that, for all computable probability distributions, the universal prefix codes associated with the conditional Chaitin complexity have expected codeword length within a constant of the Shannon entropy."
            },
            "slug": "Some-equivalences-between-Shannon-entropy-and-Leung-Yan-Cheong-Cover",
            "title": {
                "fragments": [],
                "text": "Some equivalences between Shannon entropy and Kolmogorov complexity"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "It is shown that, for all computable probability distributions, the universal prefix codes associated with the conditional Chaitin complexity have expected codeword length within a constant of the Shannon entropy."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Inf. Theory"
            },
            "year": 1978
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144369308"
                        ],
                        "name": "J. Schalkwijk",
                        "slug": "J.-Schalkwijk",
                        "structuredName": {
                            "firstName": "J.",
                            "lastName": "Schalkwijk",
                            "middleNames": [
                                "Pieter",
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Schalkwijk"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 12594686,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "966a4b2f96090a1044eda1ae271c3f94ed704380",
            "isKey": false,
            "numCitedBy": 153,
            "numCiting": 2,
            "paperAbstract": {
                "fragments": [],
                "text": "We derive a simple algorithm for the ranking of binary sequences of length n and weight w . This algorithm is then used for source encoding a memoryless binary source that generates O's with probability q and l's with probability p = 1 - q ."
            },
            "slug": "An-algorithm-for-source-coding-Schalkwijk",
            "title": {
                "fragments": [],
                "text": "An algorithm for source coding"
            },
            "tldr": {
                "abstractSimilarityScore": 89,
                "text": "This work derives a simple algorithm for the ranking of binary sequences of length n and weight w and uses it for source encoding a memoryless binary source that generates O's and l's with probability p = 1 - q."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Inf. Theory"
            },
            "year": 1972
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2059600902"
                        ],
                        "name": "T. Lynch",
                        "slug": "T.-Lynch",
                        "structuredName": {
                            "firstName": "Thomas",
                            "lastName": "Lynch",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Lynch"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 62693108,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "945244d8d312ff425c75d4ff793229688bfd645c",
            "isKey": false,
            "numCitedBy": 79,
            "numCiting": 2,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Sequence-time-coding-for-data-compression-Lynch",
            "title": {
                "fragments": [],
                "text": "Sequence time coding for data compression"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1966
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2135764"
                        ],
                        "name": "A. Kolmogorov",
                        "slug": "A.-Kolmogorov",
                        "structuredName": {
                            "firstName": "Andrei",
                            "lastName": "Kolmogorov",
                            "middleNames": [
                                "N."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Kolmogorov"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 119745517,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "83077865493592cd8ebc5c9a8b900521428491ad",
            "isKey": false,
            "numCitedBy": 2634,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Three-approaches-to-the-quantitative-definition-of-Kolmogorov",
            "title": {
                "fragments": [],
                "text": "Three approaches to the quantitative definition of information"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1968
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "31941627"
                        ],
                        "name": "N. Abramson",
                        "slug": "N.-Abramson",
                        "structuredName": {
                            "firstName": "Norman",
                            "lastName": "Abramson",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Abramson"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 122474563,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "d2f93dc1bebd82b55fb3322f9d323d5b3a69521b",
            "isKey": false,
            "numCitedBy": 537,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Information-theory-and-coding-Abramson",
            "title": {
                "fragments": [],
                "text": "Information theory and coding"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1963
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1689489"
                        ],
                        "name": "L. Davisson",
                        "slug": "L.-Davisson",
                        "structuredName": {
                            "firstName": "Lee",
                            "lastName": "Davisson",
                            "middleNames": [
                                "D."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Davisson"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 62531476,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "0225b1f0d194190c646420db2dae5292288f3540",
            "isKey": false,
            "numCitedBy": 61,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Comments-on-\"Sequence-time-coading-for-data-Davisson",
            "title": {
                "fragments": [],
                "text": "Comments on \"Sequence time coading for data compression\""
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1966
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2126645"
                        ],
                        "name": "Richard C. Pasco",
                        "slug": "Richard-C.-Pasco",
                        "structuredName": {
                            "firstName": "Richard",
                            "lastName": "Pasco",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Richard C. Pasco"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 60531818,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "6e9a6af4bc23b4cd139e671f4d1b2ca18228f660",
            "isKey": false,
            "numCitedBy": 229,
            "numCiting": 21,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Source-coding-algorithms-for-fast-data-compression-Pasco",
            "title": {
                "fragments": [],
                "text": "Source coding algorithms for fast data compression"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1976
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Arithmetic codings as number representations"
            },
            "venue": {
                "fragments": [],
                "text": "Acta Pobtech . Scandinavica , Math ."
            },
            "year": 1979
        }
    ],
    "meta_info": {
        "citationIntent": "all",
        "citationIntentCount": {},
        "citationType": "citedPapers",
        "pageNumber": 1,
        "requestedPageSize": 10,
        "sort": "relevance",
        "totalCitations": 14,
        "totalPages": 2
    },
    "page_url": "https://www.semanticscholar.org/paper/Universal-modeling-and-coding-Rissanen-Langdon/8f54bc3a24a1f01808e6e8479a11e5b0244f5523?sort=total-citations"
}
{
    "links": [
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2110842402"
                        ],
                        "name": "John B. Anderson",
                        "slug": "John-B.-Anderson",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Anderson",
                            "middleNames": [
                                "B."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "John B. Anderson"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2155117"
                        ],
                        "name": "S. M. Hladik",
                        "slug": "S.-M.-Hladik",
                        "structuredName": {
                            "firstName": "Stephan",
                            "lastName": "Hladik",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. M. Hladik"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 2808383,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "44e220c25f5604e40a86e66210501899bafc1a40",
            "isKey": false,
            "numCitedBy": 161,
            "numCiting": 7,
            "paperAbstract": {
                "fragments": [],
                "text": "We extend the MAP decoding algorithm of Bahl et al. (1974) to the case of tail-biting trellis codes. An algorithm is given that is based on finding an eigenvector, and another that avoids this. Several examples are given. The algorithm has application to turbo decoding and source-controlled channel decoding."
            },
            "slug": "Tailbiting-MAP-Decoders-Anderson-Hladik",
            "title": {
                "fragments": [],
                "text": "Tailbiting MAP Decoders"
            },
            "tldr": {
                "abstractSimilarityScore": 92,
                "text": "The MAP decoding algorithm of Bahl et al. (1974) is extended to the case of tail-biting trellis codes and an algorithm is given that is based on finding an eigenvector, and another that avoids this."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE J. Sel. Areas Commun."
            },
            "year": 1998
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1749650"
                        ],
                        "name": "B. Frey",
                        "slug": "B.-Frey",
                        "structuredName": {
                            "firstName": "Brendan",
                            "lastName": "Frey",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Frey"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "6672026"
                        ],
                        "name": "R. Kotter",
                        "slug": "R.-Kotter",
                        "structuredName": {
                            "firstName": "Ralf",
                            "lastName": "Kotter",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Kotter"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1688009"
                        ],
                        "name": "A. Vardy",
                        "slug": "A.-Vardy",
                        "structuredName": {
                            "firstName": "Alexander",
                            "lastName": "Vardy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Vardy"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 124240801,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "5f9e5908e26598b0bfbf19a145fa50291556c411",
            "isKey": false,
            "numCitedBy": 33,
            "numCiting": 5,
            "paperAbstract": {
                "fragments": [],
                "text": "Impressive performances by low-density parity-check codes and turbo codes have inspired researchers to determine how their iterative decoders depart from optimal decoding. Iterative decoding can be viewed as the application of the sum-product or min-sum algorithm in a graph that describes the constraints on a system of variables. The authors discuss here how iterative decoding maximizes correlation, and skewness and pseudocodewords in the decoding tree."
            },
            "slug": "Skewness-and-pseudocodewords-in-iterative-decoding-Frey-Kotter",
            "title": {
                "fragments": [],
                "text": "Skewness and pseudocodewords in iterative decoding"
            },
            "tldr": {
                "abstractSimilarityScore": 39,
                "text": "The authors discuss here how iterative decoding maximizes correlation, and skewness and pseudocodewords in the decoding tree."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings. 1998 IEEE International Symposium on Information Theory (Cat. No.98CH36252)"
            },
            "year": 1998
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2718299"
                        ],
                        "name": "N. Wiberg",
                        "slug": "N.-Wiberg",
                        "structuredName": {
                            "firstName": "Niclas",
                            "lastName": "Wiberg",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Wiberg"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143681410"
                        ],
                        "name": "H. Loeliger",
                        "slug": "H.-Loeliger",
                        "structuredName": {
                            "firstName": "Hans-Andrea",
                            "lastName": "Loeliger",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. Loeliger"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "7715701"
                        ],
                        "name": "R. Koetter",
                        "slug": "R.-Koetter",
                        "structuredName": {
                            "firstName": "Ralf",
                            "lastName": "Koetter",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Koetter"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 36630145,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "848822f6c3446842730587cb4373a53f69e38720",
            "isKey": false,
            "numCitedBy": 350,
            "numCiting": 11,
            "paperAbstract": {
                "fragments": [],
                "text": "Until recently, most known decoding procedures for error-correcting codes were based either on algebraically calculating the error pattern or on some sort of tree or trellis search. With the advent of turbo coding, a third decoding principle has finally had its breakthrough: iterative decoding. With respect to Viterbi decoding, a code is most naturally described by means of a trellis diagram. The main thesis of the present paper is that, with respect to iterative decoding, the natural way of describing a code is by means of a Tanner graph, which may be viewed as a generalized trellis. More precisely, it is the \"time axis\" of a trellis that is generalized to a Tanner graph."
            },
            "slug": "Codes-and-iterative-decoding-on-general-graphs-Wiberg-Loeliger",
            "title": {
                "fragments": [],
                "text": "Codes and iterative decoding on general graphs"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "The main thesis of the present paper is that, with respect to iterative decoding, the natural way of describing a code is by means of a Tanner graph, which may be viewed as a generalized trellis."
            },
            "venue": {
                "fragments": [],
                "text": "Eur. Trans. Telecommun."
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2718299"
                        ],
                        "name": "N. Wiberg",
                        "slug": "N.-Wiberg",
                        "structuredName": {
                            "firstName": "Niclas",
                            "lastName": "Wiberg",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Wiberg"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 115168171,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "eb44d50bce92b4ce2c0ea53bd8ede95f628ee3cb",
            "isKey": false,
            "numCitedBy": 1007,
            "numCiting": 52,
            "paperAbstract": {
                "fragments": [],
                "text": "Iterative decoding techniques have become a viable alternative for constructing high performance coding systems. In particular, the recent success of turbo codes indicates that performance close to the Shannon limit may be achieved. In this thesis, it is showed that many iterative decoding algorithms are special cases of two generic algorithms, the min-sum and sum-product algorithms, which also include non-iterative algorithms such as Viterbi decoding. The min-sum and sum-product algorithms are developed and presented as generalized trellis algorithms, where the time axis of the trellis is replaced by an arbitrary graph, the \u201cTanner graph\u201d. With cycle-free Tanner graphs, the resulting decoding algorithms (e.g., Viterbi decoding) are maximum-likelihood but suffer from an exponentially increasing complexity. Iterative decoding occurs when the Tanner graph has cycles (e.g., turbo codes); the resulting algorithms are in general suboptimal, but significant complexity reductions are possible compared to the cycle-free case. Several performance estimates for iterative decoding are developed, including a generalization of the union bound used with Viterbi decoding and a characterization of errors that are uncorrectable after infinitely many decoding iterations."
            },
            "slug": "Codes-and-Decoding-on-General-Graphs-Wiberg",
            "title": {
                "fragments": [],
                "text": "Codes and Decoding on General Graphs"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "It is showed that many iterative decoding algorithms are special cases of two generic algorithms, the min-sum and sum-product algorithms, which also include non-iterative algorithms such as Viterbi decoding."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144003733"
                        ],
                        "name": "A. Calderbank",
                        "slug": "A.-Calderbank",
                        "structuredName": {
                            "firstName": "A.",
                            "lastName": "Calderbank",
                            "middleNames": [
                                "Robert"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Calderbank"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144018201"
                        ],
                        "name": "G. Forney",
                        "slug": "G.-Forney",
                        "structuredName": {
                            "firstName": "G.",
                            "lastName": "Forney",
                            "middleNames": [
                                "David"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Forney"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1688009"
                        ],
                        "name": "A. Vardy",
                        "slug": "A.-Vardy",
                        "structuredName": {
                            "firstName": "Alexander",
                            "lastName": "Vardy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Vardy"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 30571190,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "c04ecb42eb18bb44d88fdb3972cc653e7d994f61",
            "isKey": false,
            "numCitedBy": 182,
            "numCiting": 52,
            "paperAbstract": {
                "fragments": [],
                "text": "Tail-biting trellis representations of block codes are investigated. We develop some elementary theory, and present several intriguing examples, which we hope will stimulate further developments in this field. In particular, we construct a 16-state 12-section structurally invariant tail-biting trellis for the (24, 12, 8) binary Golay code. This tail-biting trellis representation is minimal: it simultaneously minimizes all conceivable measures of state complexity. Moreover, it compares favorably with the minimal conventional 12-section trellis for the Golay code, which has 256 states at its midpoint, or with the best quasi-cyclic representation of this code, which leads to a 64-state tail-biting trellis. Unwrapping this tail-biting trellis produces a periodically time-varying 16-state rate-1/2 \"convolutional Golay code\" with d=8, which has attractive performance/complexity properties. We furthermore show that the (6, 3, 4) quaternary hexacode has a minimal 8-state group tail-biting trellis, even though it has no such linear trellis over F/sub 4/. Minimal tail-biting trellises are also constructed for the (8, 4, 4) binary Hamming code, the (4, 2, 3) ternary tetracode, the (4, 2, 3) code over F/sub 4/, and the Z/sub 4/-linear (8. 4, 4) octacode."
            },
            "slug": "Minimal-tail-biting-trellises:-The-Golay-code-and-Calderbank-Forney",
            "title": {
                "fragments": [],
                "text": "Minimal tail-biting trellises: The Golay code and more"
            },
            "tldr": {
                "abstractSimilarityScore": 64,
                "text": "A 16-state tail-biting trellis for the binary Golay code C/sub 24/ is exhibited, which is the first known example of a self-dual doubly-even binary linear convolutional code."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Inf. Theory"
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1889982"
                        ],
                        "name": "F. Kschischang",
                        "slug": "F.-Kschischang",
                        "structuredName": {
                            "firstName": "Frank",
                            "lastName": "Kschischang",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Kschischang"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1749650"
                        ],
                        "name": "B. Frey",
                        "slug": "B.-Frey",
                        "structuredName": {
                            "firstName": "Brendan",
                            "lastName": "Frey",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Frey"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 6522238,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "bbd45449e1cdadbf1f0c06a9510b5ac247cb70b9",
            "isKey": false,
            "numCitedBy": 425,
            "numCiting": 45,
            "paperAbstract": {
                "fragments": [],
                "text": "We present a unified graphical model framework for describing compound codes and deriving iterative decoding algorithms. After reviewing a variety of graphical models (Markov random fields, Tanner graphs, and Bayesian networks), we derive a general distributed marginalization algorithm for functions described by factor graphs. From this general algorithm, Pearl's (1986) belief propagation algorithm is easily derived as a special case. We point out that iterative decoding algorithms for various codes, including \"turbo decoding\" of parallel-concatenated convolutional codes, may be viewed as probability propagation in a graphical model of the code. We focus on Bayesian network descriptions of codes, which give a natural input/state/output/channel description of a code and channel, and we indicate how iterative decoders can be developed for parallel-and serially concatenated coding systems, product codes, and low-density parity-check codes."
            },
            "slug": "Iterative-Decoding-of-Compound-Codes-by-Probability-Kschischang-Frey",
            "title": {
                "fragments": [],
                "text": "Iterative Decoding of Compound Codes by Probability Propagation in Graphical Models"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "It is pointed out that iterative decoding algorithms for various codes, including \"turbo decoding\" of parallel-concatenated convolutional codes, may be viewed as probability propagation in a graphical model of the code."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE J. Sel. Areas Commun."
            },
            "year": 1998
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3231485"
                        ],
                        "name": "S. Aji",
                        "slug": "S.-Aji",
                        "structuredName": {
                            "firstName": "Srinivas",
                            "lastName": "Aji",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Aji"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1723150"
                        ],
                        "name": "R. McEliece",
                        "slug": "R.-McEliece",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "McEliece",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. McEliece"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 11355291,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "0e8933300a20f3d799dc9f19e352967f41d8efcc",
            "isKey": false,
            "numCitedBy": 773,
            "numCiting": 43,
            "paperAbstract": {
                "fragments": [],
                "text": "We discuss a general message passing algorithm, which we call the generalized distributive law (GDL). The GDL is a synthesis of the work of many authors in information theory, digital communications, signal processing, statistics, and artificial intelligence. It includes as special cases the Baum-Welch algorithm, the fast Fourier transform (FFT) on any finite Abelian group, the Gallager-Tanner-Wiberg decoding algorithm, Viterbi's algorithm, the BCJR algorithm, Pearl's \"belief propagation\" algorithm, the Shafer-Shenoy probability propagation algorithm, and the turbo decoding algorithm. Although this algorithm is guaranteed to give exact answers only in certain cases (the \"junction tree\" condition), unfortunately not including the cases of GTW with cycles or turbo decoding, there is much experimental evidence, and a few theorems, suggesting that it often works approximately even when it is not supposed to."
            },
            "slug": "The-generalized-distributive-law-Aji-McEliece",
            "title": {
                "fragments": [],
                "text": "The generalized distributive law"
            },
            "tldr": {
                "abstractSimilarityScore": 39,
                "text": "Although this algorithm is guaranteed to give exact answers only in certain cases (the \"junction tree\" condition), unfortunately not including the cases of GTW with cycles or turbo decoding, there is much experimental evidence, and a few theorems, suggesting that it often works approximately even when it is not supposed to."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Inf. Theory"
            },
            "year": 2000
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1770859"
                        ],
                        "name": "R. Gallager",
                        "slug": "R.-Gallager",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "Gallager",
                            "middleNames": [
                                "G."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Gallager"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 12709402,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "206f827fad201506c315d40c1469b41a45141893",
            "isKey": false,
            "numCitedBy": 10569,
            "numCiting": 25,
            "paperAbstract": {
                "fragments": [],
                "text": "A low-density parity-check code is a code specified by a parity-check matrix with the following properties: each column contains a small fixed number j \\geq 3 of l's and each row contains a small fixed number k > j of l's. The typical minimum distance of these codes increases linearly with block length for a fixed rate and fixed j . When used with maximum likelihood decoding on a sufficiently quiet binary-input symmetric channel, the typical probability of decoding error decreases exponentially with block length for a fixed rate and fixed j . A simple but nonoptimum decoding scheme operating directly from the channel a posteriori probabilities is described. Both the equipment complexity and the data-handling capacity in bits per second of this decoder increase approximately linearly with block length. For j > 3 and a sufficiently low rate, the probability of error using this decoder on a binary symmetric channel is shown to decrease at least exponentially with a root of the block length. Some experimental results show that the actual probability of decoding error is much smaller than this theoretical bound."
            },
            "slug": "Low-density-parity-check-codes-Gallager",
            "title": {
                "fragments": [],
                "text": "Low-density parity-check codes"
            },
            "tldr": {
                "abstractSimilarityScore": 39,
                "text": "A simple but nonoptimum decoding scheme operating directly from the channel a posteriori probabilities is described and the probability of error using this decoder on a binary symmetric channel is shown to decrease at least exponentially with a root of the block length."
            },
            "venue": {
                "fragments": [],
                "text": "IRE Trans. Inf. Theory"
            },
            "year": 1962
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1723150"
                        ],
                        "name": "R. McEliece",
                        "slug": "R.-McEliece",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "McEliece",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. McEliece"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145852650"
                        ],
                        "name": "D. Mackay",
                        "slug": "D.-Mackay",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Mackay",
                            "middleNames": [
                                "J.",
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Mackay"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2157745208"
                        ],
                        "name": "Jung-Fu Cheng",
                        "slug": "Jung-Fu-Cheng",
                        "structuredName": {
                            "firstName": "Jung-Fu",
                            "lastName": "Cheng",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jung-Fu Cheng"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 14553992,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "26d953005dd08a863c157b528bbabdf5671d18b6",
            "isKey": false,
            "numCitedBy": 1004,
            "numCiting": 63,
            "paperAbstract": {
                "fragments": [],
                "text": "We describe the close connection between the now celebrated iterative turbo decoding algorithm of Berrou et al. (1993) and an algorithm that has been well known in the artificial intelligence community for a decade, but which is relatively unknown to information theorists: Pearl's (1982) belief propagation algorithm. We see that if Pearl's algorithm is applied to the \"belief network\" of a parallel concatenation of two or more codes, the turbo decoding algorithm immediately results. Unfortunately, however, this belief diagram has loops, and Pearl only proved that his algorithm works when there are no loops, so an explanation of the experimental performance of turbo decoding is still lacking. However, we also show that Pearl's algorithm can be used to routinely derive previously known iterative, but suboptimal, decoding algorithms for a number of other error-control systems, including Gallager's (1962) low-density parity-check codes, serially concatenated codes, and product codes. Thus, belief propagation provides a very attractive general methodology for devising low-complexity iterative decoding algorithms for hybrid coded systems."
            },
            "slug": "Turbo-Decoding-as-an-Instance-of-Pearl's-\"Belief-McEliece-Mackay",
            "title": {
                "fragments": [],
                "text": "Turbo Decoding as an Instance of Pearl's \"Belief Propagation\" Algorithm"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "It is shown that Pearl's algorithm can be used to routinely derive previously known iterative, but suboptimal, decoding algorithms for a number of other error-control systems, including Gallager's low-density parity-check codes, serially concatenated codes, and product codes."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE J. Sel. Areas Commun."
            },
            "year": 1998
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "21233279"
                        ],
                        "name": "D. Lind",
                        "slug": "D.-Lind",
                        "structuredName": {
                            "firstName": "Douglas",
                            "lastName": "Lind",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Lind"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "37898699"
                        ],
                        "name": "B. Marcus",
                        "slug": "B.-Marcus",
                        "structuredName": {
                            "firstName": "Brian",
                            "lastName": "Marcus",
                            "middleNames": [
                                "H."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Marcus"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 61004655,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "a7b852c07fe942b0a72e042b107585e910d496c8",
            "isKey": false,
            "numCitedBy": 2604,
            "numCiting": 139,
            "paperAbstract": {
                "fragments": [],
                "text": "From the Publisher: \nAlthough it originated as a method to study general dynamical systems, symbolic dynamics is useful in coding for data storage and transmission as well as in linear algebra. Requiring only a undergraduate knowledge of linear algebra, this first general textbook includes over 500 exercises."
            },
            "slug": "An-Introduction-to-Symbolic-Dynamics-and-Coding-Lind-Marcus",
            "title": {
                "fragments": [],
                "text": "An Introduction to Symbolic Dynamics and Coding"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "Requiring only a undergraduate knowledge of linear algebra, this first general textbook includes over 500 exercises that explore symbolic dynamics as a method to study general dynamical systems."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "37898699"
                        ],
                        "name": "B. Marcus",
                        "slug": "B.-Marcus",
                        "structuredName": {
                            "firstName": "Brian",
                            "lastName": "Marcus",
                            "middleNames": [
                                "H."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Marcus"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145257061"
                        ],
                        "name": "S. Tuncel",
                        "slug": "S.-Tuncel",
                        "structuredName": {
                            "firstName": "Selim",
                            "lastName": "Tuncel",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Tuncel"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 123482405,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "95fb05ebbdb92d9045edcd3dc592cc0b7a7e488a",
            "isKey": false,
            "numCitedBy": 56,
            "numCiting": 30,
            "paperAbstract": {
                "fragments": [],
                "text": "Abstract We study Markov chains via invariants constructed from periodic orbits. Canonical extensions, based on these invariants, are used to establish a constraint on the degree of finite-to-one block homomorphisms from one Markov chain to another. We construct a polytope from the normalized weights of periodic orbits. Using this polytope, we find canonically-defined induced Markov chains inside the original Markov chain. Each of the invariants associated with these Markov chains gives rise to a scaffold of invariants for the original Markov chain. This is used to obtain counterexamples to the finite equivalence conjecture and to a conjecture regarding finitary isomorphism with finite expected coding time. Also included are results related to the problem of minimality (with respect to block homomorphism) of Bernoulli shifts in the class of Markov chains with beta function equal to the beta function of the Bernoulli shift."
            },
            "slug": "The-weight-per-symbol-polytope-and-scaffolds-of-Marcus-Tuncel",
            "title": {
                "fragments": [],
                "text": "The weight-per-symbol polytope and scaffolds of invariants associated with Markov chains"
            },
            "venue": {
                "fragments": [],
                "text": "Ergodic Theory and Dynamical Systems"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1889982"
                        ],
                        "name": "F. Kschischang",
                        "slug": "F.-Kschischang",
                        "structuredName": {
                            "firstName": "Frank",
                            "lastName": "Kschischang",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Kschischang"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1749650"
                        ],
                        "name": "B. Frey",
                        "slug": "B.-Frey",
                        "structuredName": {
                            "firstName": "Brendan",
                            "lastName": "Frey",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Frey"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143681410"
                        ],
                        "name": "H. Loeliger",
                        "slug": "H.-Loeliger",
                        "structuredName": {
                            "firstName": "Hans-Andrea",
                            "lastName": "Loeliger",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. Loeliger"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 14394619,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "08c370eb9ba13bfb836349e7f3ea428be4697818",
            "isKey": false,
            "numCitedBy": 4132,
            "numCiting": 64,
            "paperAbstract": {
                "fragments": [],
                "text": "Algorithms that must deal with complicated global functions of many variables often exploit the manner in which the given functions factor as a product of \"local\" functions, each of which depends on a subset of the variables. Such a factorization can be visualized with a bipartite graph that we call a factor graph, In this tutorial paper, we present a generic message-passing algorithm, the sum-product algorithm, that operates in a factor graph. Following a single, simple computational rule, the sum-product algorithm computes-either exactly or approximately-various marginal functions derived from the global function. A wide variety of algorithms developed in artificial intelligence, signal processing, and digital communications can be derived as specific instances of the sum-product algorithm, including the forward/backward algorithm, the Viterbi algorithm, the iterative \"turbo\" decoding algorithm, Pearl's (1988) belief propagation algorithm for Bayesian networks, the Kalman filter, and certain fast Fourier transform (FFT) algorithms."
            },
            "slug": "Factor-graphs-and-the-sum-product-algorithm-Kschischang-Frey",
            "title": {
                "fragments": [],
                "text": "Factor graphs and the sum-product algorithm"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "A generic message-passing algorithm, the sum-product algorithm, that operates in a factor graph, that computes-either exactly or approximately-various marginal functions derived from the global function."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Inf. Theory"
            },
            "year": 2001
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "30400079"
                        ],
                        "name": "Yair Weiss",
                        "slug": "Yair-Weiss",
                        "structuredName": {
                            "firstName": "Yair",
                            "lastName": "Weiss",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Yair Weiss"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 15402308,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "300f73c89bfeb6b88b9b18f63793568c3d06bee6",
            "isKey": false,
            "numCitedBy": 512,
            "numCiting": 53,
            "paperAbstract": {
                "fragments": [],
                "text": "Graphical models, such as Bayesian networks and Markov networks, represent joint distributions over a set of variables by means of a graph. When the graph is singly connected, local propagation rules of the sort proposed by Pearl (1988) are guaranteed to converge to the correct posterior probabilities. Recently a number of researchers have empirically demonstrated good performance of these same local propagation schemes on graphs with loops, but a theoretical understanding of this performance has yet to be achieved. For graphical models with a single loop, we derive an analytical relationship between the probabilities computed using local propagation and the correct marginals. Using this relationship we show a category of graphical models with loops for which local propagation gives rise to provably optimal maximum a posteriori assignments (although the computed marginals will be incorrect). We also show how nodes can use local information in the messages they receive in order to correct their computed marginals. We discuss how these results can be extended to graphical models with multiple loops and show simulation results suggesting that some properties of propagation on single-loop graphs may hold for a larger class of graphs. Specifically we discuss the implication of our results for understanding a class of recently proposed error-correcting codes known as turbo codes."
            },
            "slug": "Correctness-of-Local-Probability-Propagation-in-Weiss",
            "title": {
                "fragments": [],
                "text": "Correctness of Local Probability Propagation in Graphical Models with Loops"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "An analytical relationship is derived between the probabilities computed using local propagation and the correct marginals and a category of graphical models with loops for which local propagation gives rise to provably optimal maximum a posteriori assignments (although the computed marginals will be incorrect)."
            },
            "venue": {
                "fragments": [],
                "text": "Neural Computation"
            },
            "year": 2000
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "37898699"
                        ],
                        "name": "B. Marcus",
                        "slug": "B.-Marcus",
                        "structuredName": {
                            "firstName": "Brian",
                            "lastName": "Marcus",
                            "middleNames": [
                                "H."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Marcus"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145257061"
                        ],
                        "name": "S. Tuncel",
                        "slug": "S.-Tuncel",
                        "structuredName": {
                            "firstName": "Selim",
                            "lastName": "Tuncel",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Tuncel"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 123492707,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "2355f81305b4c5890070ddd3c9222bbba35bd1d7",
            "isKey": false,
            "numCitedBy": 25,
            "numCiting": 20,
            "paperAbstract": {
                "fragments": [],
                "text": "We consider the ring R = ]R[xt, ... ,xt] of Laurent polynomials with real coefficients in the variables XI\"'\" x k and its positive cone R+ = ]R+[xt, ... , xt]. Letting]R++ denote the positive reals, we also have the set R++ = ]R++[xt ' ... ,xt] of polynomials with positive coefficients, so that R+ = R++ U {O}. We say that pER is numerically positive if p gives a positive value whenever we substitute positive numbers for XI' ... , xk ' that is, if P(XI' ... , xk) > 0 for XI ' ... , xk > O. Every element of R++ is numerically positive; however, there are numerically positive polynomials that are not elements of R++ . This distinction lies at the heart of the paper; we will discuss it in greater detail in \u00a72. Let B be a square matrix over R+ . Whenever we substitute positive numbers for XI\"'\" xk ' we get a nonnegative real-valued matrix. We assume that the matrix resulting from one, hence every, such evaluation is irreducible and, for XI' ... , xk > 0, let P(x l , \u2022\u2022\u2022 , xk) > 0 be the maximum eigenvalue of B(xI' ... ,xk) furnished by the Perron-Frobenius theorem. The function P = P B: (]R++)k --+]R++ is called the p-function of B; it satisfies the characteristic polynomial XB of B, a monic polynomial whose coefficients lie in R. Thus, P is algebraic over R. We assume P has degree one; that is, we consider the case pER. This is a significant case. For instance, for any P E R++ , we obtain numerous examples of matrices with P B = P by simply requiring that B have its row (or column) sums equal to p. There are also many examples of B with PB E R\\R+ (see [D]). Since PER, the entries of the adjoint Adj(PI -B) belong to R. Moreover, by Perron-Frobenius theory [Se], the entries are numerically positive and any column r of Adj(PI B) satisfies Br = pr. So, as an immediate consequence of Perron-Frobenius theory, we find an eigenvector r whose entries are numerically positive polynomials. One of the main purposes of this paper is to show that B has an eigenvector whose entries lie in R++ ."
            },
            "slug": "Matrices-of-polynomials,-positivity,-and-finite-of-Marcus-Tuncel",
            "title": {
                "fragments": [],
                "text": "Matrices of polynomials, positivity, and finite equivalence of Markov chains"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1993
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2071084394"
                        ],
                        "name": "Elise E. Cawley",
                        "slug": "Elise-E.-Cawley",
                        "structuredName": {
                            "firstName": "Elise",
                            "lastName": "Cawley",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Elise E. Cawley"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "37898699"
                        ],
                        "name": "B. Marcus",
                        "slug": "B.-Marcus",
                        "structuredName": {
                            "firstName": "Brian",
                            "lastName": "Marcus",
                            "middleNames": [
                                "H."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Marcus"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145257061"
                        ],
                        "name": "S. Tuncel",
                        "slug": "S.-Tuncel",
                        "structuredName": {
                            "firstName": "Selim",
                            "lastName": "Tuncel",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Tuncel"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 120493945,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "4dd7f81d5d35db6917c066ec8af54e686eb730aa",
            "isKey": false,
            "numCitedBy": 1,
            "numCiting": 5,
            "paperAbstract": {
                "fragments": [],
                "text": "It is known that each Markov chain has associated with it a polytope and a family of Markov measures indexed by the interior points of the polytope. Measure-preserving factor maps between Markov chains must preserve the associated families. In the present paper, we augment this structure by identifying measures corresponding to points on the boundary of the polytope. These measures are also preserved by factor maps. We examine the data they provide and give examples to illustrate the use of this data in ruling out the existence of factor maps between Markov chains."
            },
            "slug": "Boundary-measures-of-Markov-chains-Cawley-Marcus",
            "title": {
                "fragments": [],
                "text": "Boundary measures of Markov chains"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "47688546"
                        ],
                        "name": "P. J. Higgins",
                        "slug": "P.-J.-Higgins",
                        "structuredName": {
                            "firstName": "Philip",
                            "lastName": "Higgins",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. J. Higgins"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 122075501,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "919f09a9aac82187f0bef4c502b03d0d29a98ad3",
            "isKey": false,
            "numCitedBy": 17,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "First-Course-in-Abstract-Algebra-Higgins",
            "title": {
                "fragments": [],
                "text": "First Course in Abstract Algebra"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1975
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "48500405"
                        ],
                        "name": "E. Hille",
                        "slug": "E.-Hille",
                        "structuredName": {
                            "firstName": "Einar",
                            "lastName": "Hille",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. Hille"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                }
            ],
            "citationContexts": [],
            "corpusId": 123084991,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "9e5072b36ed679d89a7b21f88317d3e417a13c27",
            "isKey": false,
            "numCitedBy": 874,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Analytic-Function-Theory-Hille",
            "title": {
                "fragments": [],
                "text": "Analytic Function Theory"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1959
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "48500405"
                        ],
                        "name": "E. Hille",
                        "slug": "E.-Hille",
                        "structuredName": {
                            "firstName": "Einar",
                            "lastName": "Hille",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. Hille"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1395586452"
                        ],
                        "name": "G. Weiss",
                        "slug": "G.-Weiss",
                        "structuredName": {
                            "firstName": "George",
                            "lastName": "Weiss",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Weiss"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 121003028,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "9b1ff54cd690a93243e602de067272f34a0aab1e",
            "isKey": false,
            "numCitedBy": 88,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Analytic-Function-Theory,-Volume-2-Hille-Weiss",
            "title": {
                "fragments": [],
                "text": "Analytic Function Theory, Volume 2"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1962
        }
    ],
    "meta_info": {
        "citationIntent": "all",
        "citationIntentCount": {},
        "citationType": "citedPapers",
        "pageNumber": 1,
        "requestedPageSize": 10,
        "sort": "relevance",
        "totalCitations": 18,
        "totalPages": 2
    },
    "page_url": "https://www.semanticscholar.org/paper/Iterative-Decoding-of-Tail-Biting-Trellises-and-Forney-Kschischang/e2dbaa4dfcffcb2671b946cf583766a02fa709a8?sort=total-citations"
}
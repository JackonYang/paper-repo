{
    "links": [
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "78659204"
                        ],
                        "name": "M. Mohri",
                        "slug": "M.-Mohri",
                        "structuredName": {
                            "firstName": "Mehryar",
                            "lastName": "Mohri",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Mohri"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 182,
                                "start": 170
                            }
                        ],
                        "text": "The algorithm extends to the case of transducers outputting weights our determinization algorithm for string-to-string transducers representing psubsequential functions (Mohri, 1994c)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 219,
                                "start": 207
                            }
                        ],
                        "text": "In all those areas, the determinization algorithm can be used to obtain a p-subsequential transducer (Mohri, 1996b), and the minimization algorithm to reduce the size of the p-subsequential transducer used (Mohri, 1994b)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 34,
                                "start": 22
                            }
                        ],
                        "text": "Both determinization (Mohri, 1994c) and minimization algorithms (Mohri, 1994b) have been defined for the class of p-subsequential transducers which includes\nMohri Transducers in Language and Speech\nsequential string-to-string transducers."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 93,
                                "start": 81
                            }
                        ],
                        "text": "In order to deal with ambiguities one can introduce p-subsequential transducers (Mohri, 1994a), namely transducers provided with at most p final output strings at each final state."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 155,
                                "start": 143
                            }
                        ],
                        "text": "Finite-state machines are also currently used to represent local syntactic constraints (Silberztein, 1993; Roche, 1993; Karlsson et al., 1995; Mohri, 1994d)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 7075193,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "8f8686e0bd7db0fc2f9eddda2f24aea71f85d863",
            "isKey": false,
            "numCitedBy": 166,
            "numCiting": 47,
            "paperAbstract": {
                "fragments": [],
                "text": "We describe new applications of the theory of automata to natural language processing: the representation of very large scale dictionaries and the indexation of natural language texts. They are based on new algorithms that we introduce and describe in detail. In particular, we give pseudocodes for the determinisation of string to string transducers, the deterministic union of p-subsequential string to string transducers, and the indexation by automata. We report on several experiments illustrating the applications."
            },
            "slug": "On-some-applications-of-finite-state-automata-to-Mohri",
            "title": {
                "fragments": [],
                "text": "On some applications of finite-state automata theory to natural language processing"
            },
            "tldr": {
                "abstractSimilarityScore": 93,
                "text": "New applications of the theory of automata to natural language processing: the representation of very large scale dictionaries and the indexation of natural language texts are described based on new algorithms that are introduced and described in detail."
            },
            "venue": {
                "fragments": [],
                "text": "Nat. Lang. Eng."
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145366908"
                        ],
                        "name": "Fernando C Pereira",
                        "slug": "Fernando-C-Pereira",
                        "structuredName": {
                            "firstName": "Fernando",
                            "lastName": "Pereira",
                            "middleNames": [
                                "C"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Fernando C Pereira"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145428168"
                        ],
                        "name": "M. Riley",
                        "slug": "M.-Riley",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Riley",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Riley"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145421878"
                        ],
                        "name": "R. Sproat",
                        "slug": "R.-Sproat",
                        "structuredName": {
                            "firstName": "Richard",
                            "lastName": "Sproat",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Sproat"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 1320875,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "39e5fbed9b4928f4e88483e1f52c69d01396fb8a",
            "isKey": false,
            "numCitedBy": 107,
            "numCiting": 24,
            "paperAbstract": {
                "fragments": [],
                "text": "We present the concepts of weighted language, transduction and automaton from algebraic automata theory as a general framework for describing and implementing decoding cascades in speech and language processing. This generality allows us to represent uniformly such information sources as pronunciation dictionaries, language models and lattices, and to use uniform algorithms for building decoding stages and for optimizing and combining them. In particular, a single automata join algorithm can be used either to combine information sources such as a pronunciation dictionary and a context-dependency model during the construction of a decoder, or dynamically during the operation of the decoder. Applications to speech recognition and to Chinese text segmentation will be discussed."
            },
            "slug": "Weighted-Rational-Transductions-and-their-to-Human-Pereira-Riley",
            "title": {
                "fragments": [],
                "text": "Weighted Rational Transductions and their Application to Human Language Processing"
            },
            "tldr": {
                "abstractSimilarityScore": 79,
                "text": "The concepts of weighted language, transduction and automaton from algebraic automata theory are presented as a general framework for describing and implementing decoding cascades in speech and language processing and applications to speech recognition and Chinese text segmentation are discussed."
            },
            "venue": {
                "fragments": [],
                "text": "HLT"
            },
            "year": 1994
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "78659204"
                        ],
                        "name": "M. Mohri",
                        "slug": "M.-Mohri",
                        "structuredName": {
                            "firstName": "Mehryar",
                            "lastName": "Mohri",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Mohri"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 182,
                                "start": 170
                            }
                        ],
                        "text": "The algorithm extends to the case of transducers outputting weights our determinization algorithm for string-to-string transducers representing psubsequential functions (Mohri, 1994c)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 219,
                                "start": 207
                            }
                        ],
                        "text": "In all those areas, the determinization algorithm can be used to obtain a p-subsequential transducer (Mohri, 1996b), and the minimization algorithm to reduce the size of the p-subsequential transducer used (Mohri, 1994b)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 34,
                                "start": 22
                            }
                        ],
                        "text": "Both determinization (Mohri, 1994c) and minimization algorithms (Mohri, 1994b) have been defined for the class of p-subsequential transducers which includes\nMohri Transducers in Language and Speech\nsequential string-to-string transducers."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [],
                        "text": "Classical and new theorems help to indicate the usefulness of these devices as well as their characterization."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 93,
                                "start": 81
                            }
                        ],
                        "text": "In order to deal with ambiguities one can introduce p-subsequential transducers (Mohri, 1994a), namely transducers provided with at most p final output strings at each final state."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 155,
                                "start": 143
                            }
                        ],
                        "text": "Finite-state machines are also currently used to represent local syntactic constraints (Silberztein, 1993; Roche, 1993; Karlsson et al., 1995; Mohri, 1994d)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 7387856,
            "fieldsOfStudy": [
                "Biology"
            ],
            "id": "e0b9de208a65165fb99b5f2ba9c84707dcdf3687",
            "isKey": false,
            "numCitedBy": 30,
            "numCiting": 20,
            "paperAbstract": {
                "fragments": [],
                "text": "Finite-state transducers give efficient representations of many Natural Language phenomena. They allow to account for complex lexicon restrictions encountered, without involving the use of a large set of complex rules difficult to analyze. We here show that these representations can be made very compact, indicate how to perform the corresponding minimization, and point out interesting linguistic side-effects of this operation."
            },
            "slug": "Compact-Representations-by-Finite-State-Transducers-Mohri",
            "title": {
                "fragments": [],
                "text": "Compact Representations by Finite-State Transducers"
            },
            "tldr": {
                "abstractSimilarityScore": 46,
                "text": "It is shown that finite-state transducers can be made very compact, indicate how to perform the corresponding minimization, and point out interesting linguistic side-effects of this operation."
            },
            "venue": {
                "fragments": [],
                "text": "ACL"
            },
            "year": 1994
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "78659204"
                        ],
                        "name": "M. Mohri",
                        "slug": "M.-Mohri",
                        "structuredName": {
                            "firstName": "Mehryar",
                            "lastName": "Mohri",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Mohri"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145421878"
                        ],
                        "name": "R. Sproat",
                        "slug": "R.-Sproat",
                        "structuredName": {
                            "firstName": "Richard",
                            "lastName": "Sproat",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Sproat"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 96,
                                "start": 74
                            }
                        ],
                        "text": "These observations can be extended to the case of weighted rewrite rules (Mohri and Sproat, 1996)."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 48940,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "30cd6bab1201af143cd7c7e1520c3d334642c9ce",
            "isKey": false,
            "numCitedBy": 154,
            "numCiting": 30,
            "paperAbstract": {
                "fragments": [],
                "text": "Context-dependent rewrite rules are used in many areas of natural language and speech processing. Work in computational phonology has demonstrated that, given certain conditions, such rewrite rules can be represented as finite-state transducers (FSTs). We describe a new algorithm for compiling rewrite rules into FSTs. We show the algorithm to be simpler and more efficient than existing algorithms. Further, many of our applications demand the ability to compile weighted rules into weighted FSTs, transducers generalized by providing transitions with weights. We have extended the algorithm to allow for this."
            },
            "slug": "An-Efficient-Compiler-for-Weighted-Rewrite-Rules-Mohri-Sproat",
            "title": {
                "fragments": [],
                "text": "An Efficient Compiler for Weighted Rewrite Rules"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "This work describes a new algorithm for compiling rewrite rules into finite-state transducers, and shows it to be simpler and more efficient than existing algorithms."
            },
            "venue": {
                "fragments": [],
                "text": "ACL"
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "9079926"
                        ],
                        "name": "W. Woods",
                        "slug": "W.-Woods",
                        "structuredName": {
                            "firstName": "William",
                            "lastName": "Woods",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Woods"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 136,
                                "start": 114
                            }
                        ],
                        "text": "An efficient polynomial algorithm for testing the sequentiability of transducers based on this proof was given by Weber and Klemm (1995)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 18366823,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "09550accec47459a61fe1710a0a32c2ec22449bd",
            "isKey": false,
            "numCitedBy": 1450,
            "numCiting": 36,
            "paperAbstract": {
                "fragments": [],
                "text": "The use of augmented transition network grammars for the analysis of natural language sentences is described. Structure-building actions associated with the arcs of the grammar network allow for the reordering, restructuring, and copying of constituents necessary to produce deep-structure representations of the type normally obtained from a transformational analysis, and conditions on the arcs allow for a powerful selectivity which can rule out meaningless analyses and take advantage of semantic information to guide the parsing. The advantages of this model for natural language analysis are discussed in detail and illustrated by examples. An implementation of an experimental parsing system for transition network grammars is briefly described."
            },
            "slug": "Transition-network-grammars-for-natural-language-Woods",
            "title": {
                "fragments": [],
                "text": "Transition network grammars for natural language analysis"
            },
            "tldr": {
                "abstractSimilarityScore": 75,
                "text": "The use of augmented transition network grammars for the analysis of natural language sentences is described, and structure-building actions associated with the arcs of the grammar network allow for a powerful selectivity which can rule out meaningless analyses and take advantage of semantic information to guide the parsing."
            },
            "venue": {
                "fragments": [],
                "text": "CACM"
            },
            "year": 1970
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2499818"
                        ],
                        "name": "C. C. Elgot",
                        "slug": "C.-C.-Elgot",
                        "structuredName": {
                            "firstName": "Calvin",
                            "lastName": "Elgot",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. C. Elgot"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "47689217"
                        ],
                        "name": "J. Mezei",
                        "slug": "J.-Mezei",
                        "structuredName": {
                            "firstName": "Jorge",
                            "lastName": "Mezei",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Mezei"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 33,
                                "start": 10
                            }
                        ],
                        "text": "Theorem 4 (Elgot and Mezei, 1965) Let f be a partial function mapping to ."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 51,
                                "start": 29
                            }
                        ],
                        "text": "The following theorem due to Elgot and Mezei (1965) shows however that transducers are exactly compositions of left and right sequential transducers."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 32,
                                "start": 11
                            }
                        ],
                        "text": "Theorem 4 (Elgot and Mezei, 1965) Let f be a partial function mapping to . f is rational iff there exist a left sequential function l : ! and a right sequential function r : ! such that f = r \u00c6 l.\nLeft sequential functions or transducers are those we previously defined."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 6911028,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "f4655fb7bb182ad64775040710c425c5b891d59b",
            "isKey": true,
            "numCitedBy": 356,
            "numCiting": 7,
            "paperAbstract": {
                "fragments": [],
                "text": "A transduction, in the sense of this paper, is a n-ary word relation (which may be a function) describable by a finite directed labeled graph. The notion of n-ary transduction is co-extensive with the Kleenean closure of finite n-ary relations. The 1-ary transductions are exactly the sets recognizable by finite automata. However, for n > 1 the relations recognizable by automata constitute a proper subclass of the n-ary transductions. The 2-ary length-preserving transductions constitute the equilibrium (potential) behavior of 1-dimensional, bilateral iterative networks. The immediate consequencer elation of various primitive deductive (respectively computational) systems, such as Post normal systems (respectively Turing machines) are examples of transductions. Other riches deductive systems have immediate consequence relations which are not transductions. The closure properties of the class of transductions are studied. The decomposition of transductions into simpler ones is also studied."
            },
            "slug": "On-Relations-Defined-by-Generalized-Finite-Automata-Elgot-Mezei",
            "title": {
                "fragments": [],
                "text": "On Relations Defined by Generalized Finite Automata"
            },
            "tldr": {
                "abstractSimilarityScore": 74,
                "text": "A transduction, in the sense of this paper, is a n-ary word relation (which may be a function) describable by a finite directed labeled graph that constitutes the equilibrium (potential) behavior of 1-dimensional, bilateral iterative networks."
            },
            "venue": {
                "fragments": [],
                "text": "IBM J. Res. Dev."
            },
            "year": 1965
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143939841"
                        ],
                        "name": "M. Weber",
                        "slug": "M.-Weber",
                        "structuredName": {
                            "firstName": "M",
                            "lastName": "Weber",
                            "middleNames": [
                                "C"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Weber"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "153156486"
                        ],
                        "name": "R. Klemm",
                        "slug": "R.-Klemm",
                        "structuredName": {
                            "firstName": "Reinhard",
                            "lastName": "Klemm",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Klemm"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 136,
                                "start": 114
                            }
                        ],
                        "text": "An efficient polynomial algorithm for testing the sequentiability of transducers based on this proof was given by Weber and Klemm (1995)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 21025237,
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "id": "c1200aeb978a40d04b313d5f2f638d0dd4273a09",
            "isKey": false,
            "numCitedBy": 42,
            "numCiting": 20,
            "paperAbstract": {
                "fragments": [],
                "text": "Questions of economy of description are investigated in connection with single-valued finite transducers. The following results are shown. (1) Any single-valued real-time transducer M with n states can be effectively transformed into an equivalent unambiguous real-time transducer having at most 2n states. (2) Let M be a single-valued real-time transducer with n states and output alphabet \u03b4 which is equivalent to some deterministic real-time or subsequential transducer M\u2032. Then, M can be effectively transformed into such an M\u2032 having at most \\(1 + 2^n \\cdot \\max \\left\\{ {2,\\# \\Delta } \\right\\}^{2n^3 l}\\) states where l is a local structural parameter of M. (3) For any single-valued real-time transducer M it is decidable in deterministic polynomial time whether or not it is equivalent to some deterministic real-time transducer (to some subsequential transducer, respectively). The results (1)\u2013(3) can be extended to the case that M is not real time. The upper bound in (1) is at most one state off the optimal upper bound. Any improvement of the upper bound in (2) is greater or equal than 2n."
            },
            "slug": "Economy-of-Description-for-Single-Valued-Weber-Klemm",
            "title": {
                "fragments": [],
                "text": "Economy of Description for Single-valued Transducers"
            },
            "tldr": {
                "abstractSimilarityScore": 46,
                "text": "For any single-valued real-time transducer M it is decidable in deterministic polynomial time whether or not it is equivalent to some deterministic real- timeTransducer (to some subsequential transducers, respectively)."
            },
            "venue": {
                "fragments": [],
                "text": "STACS"
            },
            "year": 1994
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "78659204"
                        ],
                        "name": "M. Mohri",
                        "slug": "M.-Mohri",
                        "structuredName": {
                            "firstName": "Mehryar",
                            "lastName": "Mohri",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Mohri"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 182,
                                "start": 170
                            }
                        ],
                        "text": "The algorithm extends to the case of transducers outputting weights our determinization algorithm for string-to-string transducers representing psubsequential functions (Mohri, 1994c)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 219,
                                "start": 207
                            }
                        ],
                        "text": "In all those areas, the determinization algorithm can be used to obtain a p-subsequential transducer (Mohri, 1996b), and the minimization algorithm to reduce the size of the p-subsequential transducer used (Mohri, 1994b)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 34,
                                "start": 22
                            }
                        ],
                        "text": "Both determinization (Mohri, 1994c) and minimization algorithms (Mohri, 1994b) have been defined for the class of p-subsequential transducers which includes\nMohri Transducers in Language and Speech\nsequential string-to-string transducers."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 93,
                                "start": 81
                            }
                        ],
                        "text": "In order to deal with ambiguities one can introduce p-subsequential transducers (Mohri, 1994a), namely transducers provided with at most p final output strings at each final state."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 155,
                                "start": 143
                            }
                        ],
                        "text": "Finite-state machines are also currently used to represent local syntactic constraints (Silberztein, 1993; Roche, 1993; Karlsson et al., 1995; Mohri, 1994d)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 17752743,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "20ab77f577b3b1db5c6b13b81fec6ea30f7d9267",
            "isKey": false,
            "numCitedBy": 50,
            "numCiting": 13,
            "paperAbstract": {
                "fragments": [],
                "text": "We present an algorithm for minimizing sequential transducers. This algorithm is shown to be efficient, since in the case of acyclic transducers it operates in O(\u00a6E\u00a6+\u00a6V\u00a6+(E\u00a6\u2212\u00a6V\u00a6+\u00a6F\u00a6).(\u00a6P max \u00a6+1) steps, where E is the set of edges of the given transducer, V the set of its vertices, F the set of final states, and P max the longest of the greatest common prefixes of the output paths leaving each state of the transducer. It can be applied to a larger class of transducers which includes subsequential transducers."
            },
            "slug": "Minimization-of-Sequential-Transducers-Mohri",
            "title": {
                "fragments": [],
                "text": "Minimization of Sequential Transducers"
            },
            "tldr": {
                "abstractSimilarityScore": 86,
                "text": "An algorithm for minimizing sequential transducers is presented, which is shown to be efficient, since in the case of acyclic transducers it operates in O(\u00a6E\u00a6+\u00a6V\u00a6 +\u00a6F\u00a6)+\u00a6P max steps."
            },
            "venue": {
                "fragments": [],
                "text": "CPM"
            },
            "year": 1994
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2362352"
                        ],
                        "name": "M. Sch\u00fctzenberger",
                        "slug": "M.-Sch\u00fctzenberger",
                        "structuredName": {
                            "firstName": "Marcel",
                            "lastName": "Sch\u00fctzenberger",
                            "middleNames": [
                                "Paul"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Sch\u00fctzenberger"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 5041688,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "04cce338d310bbec946b9084bc3da7c706d4b4bf",
            "isKey": false,
            "numCitedBy": 662,
            "numCiting": 3,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "On-the-Definition-of-a-Family-of-Automata-Sch\u00fctzenberger",
            "title": {
                "fragments": [],
                "text": "On the Definition of a Family of Automata"
            },
            "venue": {
                "fragments": [],
                "text": "Inf. Control."
            },
            "year": 1961
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144017417"
                        ],
                        "name": "M. Crochemore",
                        "slug": "M.-Crochemore",
                        "structuredName": {
                            "firstName": "Maxime",
                            "lastName": "Crochemore",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Crochemore"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 8482161,
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "id": "bf76bf1f758b172a378e331d1cbf5234b145c8bf",
            "isKey": false,
            "numCitedBy": 228,
            "numCiting": 26,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Transducers-and-Repetitions-Crochemore",
            "title": {
                "fragments": [],
                "text": "Transducers and Repetitions"
            },
            "venue": {
                "fragments": [],
                "text": "Theor. Comput. Sci."
            },
            "year": 1986
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143875389"
                        ],
                        "name": "D. Perrin",
                        "slug": "D.-Perrin",
                        "structuredName": {
                            "firstName": "Dominique",
                            "lastName": "Perrin",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Perrin"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 91701,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "05b34ffcabdb2748f3172dc6b38e9222408ee23b",
            "isKey": false,
            "numCitedBy": 688,
            "numCiting": 52,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Finite-Automata-Perrin",
            "title": {
                "fragments": [],
                "text": "Finite Automata"
            },
            "venue": {
                "fragments": [],
                "text": "Handbook of Theoretical Computer Science, Volume B: Formal Models and Sematics"
            },
            "year": 1990
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "78659204"
                        ],
                        "name": "M. Mohri",
                        "slug": "M.-Mohri",
                        "structuredName": {
                            "firstName": "Mehryar",
                            "lastName": "Mohri",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Mohri"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 35552084,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "2353957a8f40b59d3e39ed85d12e0813e04354da",
            "isKey": false,
            "numCitedBy": 11,
            "numCiting": 15,
            "paperAbstract": {
                "fragments": [],
                "text": "We present an algorithm permitting to search in a text for the patterns of a regular set. Unlike many classical algorithms, we shall assume that the input of the algorithm is a deterministic automaton and not a regular expression. Our algorithm is based on the notion of failure function and mainly consists in efficiently constructing a new deterministic automaton. This construction is shown to be more efficient both in time and space than naive algorithms such as the powerset algorithm used for determinization. In particular, its space complexity is linear in the size of the obtained automaton."
            },
            "slug": "Matching-Patterns-of-An-Automaton-Mohri",
            "title": {
                "fragments": [],
                "text": "Matching Patterns of An Automaton"
            },
            "tldr": {
                "abstractSimilarityScore": 45,
                "text": "This algorithm is based on the notion of failure function and mainly consists in efficiently constructing a new deterministic automaton, which is shown to be more efficient both in time and space than naive algorithms such as the powerset algorithm used for determinization."
            },
            "venue": {
                "fragments": [],
                "text": "CPM"
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "46278220"
                        ],
                        "name": "Emmanuel Roche",
                        "slug": "Emmanuel-Roche",
                        "structuredName": {
                            "firstName": "Emmanuel",
                            "lastName": "Roche",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Emmanuel Roche"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1725500"
                        ],
                        "name": "Yves Schabes",
                        "slug": "Yves-Schabes",
                        "structuredName": {
                            "firstName": "Yves",
                            "lastName": "Schabes",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Yves Schabes"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "Since that use consists of following the only path corresponding to the input string and in writing consecutive output labels along this path, the total computational time is linear in the size of the input, if we consider that the cost of copying out each output label does not depend on its length."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 161,
                                "start": 149
                            }
                        ],
                        "text": "As an example, a French morphological dictionary of about 21:2 Mb can be compiled into ap-subsequential transducer of size 1:3 Mb, in a few minutes (Mohri, 1996b)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 114,
                                "start": 102
                            }
                        ],
                        "text": "In all those areas, the determinization algorithm can be used to obtain a p-subsequential transducer (Mohri, 1996b), and the minimization algorithm to reduce the size of the p-subsequential transducer used (Mohri, 1994b)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 17,
                                "start": 5
                            }
                        ],
                        "text": "See (Mohri, 1996b) for a full description of this algorithm."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 132,
                                "start": 120
                            }
                        ],
                        "text": "For a more detailed overview of the applications of sequential string to string transducers to language processing see (Mohri, 1996a)."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 63390656,
            "fieldsOfStudy": [
                "Linguistics",
                "Biology"
            ],
            "id": "0697b6a36b9c838523af4a7209d708a17bc85254",
            "isKey": true,
            "numCitedBy": 22,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "This chapter contains sections titled: Introduction, Definitions, Characterization and Extensions, Phonology and Morphology, Representation of Large Dictionaries, Syntax, Speech Processing, Conclusion, Acknowledgments, References"
            },
            "slug": "On-the-Use-of-Sequential-Transducers-in-Natural-Roche-Schabes",
            "title": {
                "fragments": [],
                "text": "On the Use of Sequential Transducers in Natural Language Processing"
            },
            "tldr": {
                "abstractSimilarityScore": 100,
                "text": "This chapter contains sections titled: Introduction, Definitions, Characterization and Extensions, Phonology and Morphology, Representation of Large Dictionaries, Syntax, Speech Processing, Conclusion, Acknowledgments, References."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1997
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2032839"
                        ],
                        "name": "J. Carlyle",
                        "slug": "J.-Carlyle",
                        "structuredName": {
                            "firstName": "Jack",
                            "lastName": "Carlyle",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Carlyle"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145007287"
                        ],
                        "name": "A. Paz",
                        "slug": "A.-Paz",
                        "structuredName": {
                            "firstName": "Azaria",
                            "lastName": "Paz",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Paz"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                }
            ],
            "citationContexts": [],
            "corpusId": 205894839,
            "fieldsOfStudy": [
                "Mathematics",
                "Computer Science"
            ],
            "id": "c49838c33a6d190dea1981a04f54ee3443ac607b",
            "isKey": false,
            "numCitedBy": 108,
            "numCiting": 10,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Realizations-by-Stochastic-Finite-Automata-Carlyle-Paz",
            "title": {
                "fragments": [],
                "text": "Realizations by Stochastic Finite Automata"
            },
            "venue": {
                "fragments": [],
                "text": "J. Comput. Syst. Sci."
            },
            "year": 1971
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1803660"
                        ],
                        "name": "R. Kaplan",
                        "slug": "R.-Kaplan",
                        "structuredName": {
                            "firstName": "Ronald",
                            "lastName": "Kaplan",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Kaplan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145493610"
                        ],
                        "name": "M. Kay",
                        "slug": "M.-Kay",
                        "structuredName": {
                            "firstName": "Martin",
                            "lastName": "Kay",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Kay"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 134,
                                "start": 114
                            }
                        ],
                        "text": "Similarly, context-dependent phonological and morphological rules can be represented by finite-state transducers (Kaplan and Kay, 1994)."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 168,
                                "start": 148
                            }
                        ],
                        "text": "\u2026processing which range from the construction of lexical analyzers (Silberztein, 1993) and the compilation of morphological and phonological rules (Kaplan and Kay, 1994; Karttunen, Kaplan, and Zaenen, 1992) to speech processing (Mohri, Pereira, and Riley, 1996) show the usefulness of finite-state\u2026"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 64,
                                "start": 43
                            }
                        ],
                        "text": "The result of the computation described by Kaplan and Kay (1994) is not necessarily a p-subsequential transducer."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 15971472,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "6c3f94fc15407398c8f9d4bec893b02ed0dbe452",
            "isKey": true,
            "numCitedBy": 828,
            "numCiting": 25,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper presents a set of mathematical and computational tools for manipulating and reasoning about regular languages and regular relations and argues that they provide a solid basis for computational phonology. It shows in detail how this framework applies to ordered sets of context-sensitive rewriting rules and also to grammars in Koskenniemi's two-level formalism. This analysis provides a common representation of phonological constraints that supports efficient generation and recognition by a single simple interpreter."
            },
            "slug": "Regular-Models-of-Phonological-Rule-Systems-Kaplan-Kay",
            "title": {
                "fragments": [],
                "text": "Regular Models of Phonological Rule Systems"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "This paper shows in detail how this framework applies to ordered sets of context-sensitive rewriting rules and also to grammars in Koskenniemi's two-level formalism."
            },
            "venue": {
                "fragments": [],
                "text": "Comput. Linguistics"
            },
            "year": 1994
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1684537"
                        ],
                        "name": "W. Kuich",
                        "slug": "W.-Kuich",
                        "structuredName": {
                            "firstName": "Werner",
                            "lastName": "Kuich",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Kuich"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1739643"
                        ],
                        "name": "A. Salomaa",
                        "slug": "A.-Salomaa",
                        "structuredName": {
                            "firstName": "Arto",
                            "lastName": "Salomaa",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Salomaa"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 42103532,
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "id": "b9043cc0ad5e73749f0338950a118c98c607f539",
            "isKey": false,
            "numCitedBy": 541,
            "numCiting": 17,
            "paperAbstract": {
                "fragments": [],
                "text": "I. Linear Algebra.- 1. Semirings and Power Series.- 2. Convergence, Equations and Identities.- 3. Strong Convergence and Cycle-Free Power Series.- 4. Matrices, Linear Systems and Identities.- 5. Semirings with Particular Properties.- 6. Morphisms and Representations.- II. Automata.- 7. Automata in Terms of Matrices.- 8. Rational Power Series and Decidability.- 9. Rational Transductions.- 10. Pushdown Automata.- 11. Abstract Families of Power Series.- 12. Substitutions.- 13. Reset Pushdown Automata and Counter Automata.- III. Algebraic Systems.- 14. Algebraic Series and Context-Free Languages.- 15. The Super Normal Form.- 16. Commuting Variables: Decidability and Parikh's Theorem.- Historical and Bibliographical Remarks.- References.- Symbol Index."
            },
            "slug": "Semirings,-Automata,-Languages-Kuich-Salomaa",
            "title": {
                "fragments": [],
                "text": "Semirings, Automata, Languages"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "This chapter discusses automata in terms of Matrices, and discusses Commuting Variables: Decidability and Parikh's Theorem, as well as algebraic systems and Context-Free Languages."
            },
            "venue": {
                "fragments": [],
                "text": "EATCS Monographs on Theoretical Computer Science"
            },
            "year": 1986
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2997105"
                        ],
                        "name": "F. Urbanek",
                        "slug": "F.-Urbanek",
                        "structuredName": {
                            "firstName": "Friedrich",
                            "lastName": "Urbanek",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Urbanek"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 9514011,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "aff18538f2fff98f1b77564ad5f6948bd27d0cf4",
            "isKey": false,
            "numCitedBy": 5,
            "numCiting": 5,
            "paperAbstract": {
                "fragments": [],
                "text": "Given a DFA M , can we find an equivalent DFA (i.e., one that recognizes the same language as M) with the minimum possible number of states? This is a very natural question, and has important applications to the efficiency of procedures that use finite automata. In this note, we will see an efficient algorithm that solves this problem. To begin, we need a couple of definitions. Let M be any DFA with alphabet \u03a3. Then M naturally defines an equivalence relation \u223c M over \u03a3 * , given by x \u223c M y iff M ends in the same state on inputs x and y. Note that the number of equivalence classes is finite (being equal to the number of states of M). Now let L = L(M) be the language recognized by M. This language also defines a natural equivalence relation \u223c L , as follows. Call two strings x, y \u2208 \u03a3 * indistinguishable by L if, for all z \u2208 \u03a3 * , xz \u2208 L \u21d4 yz \u2208 L. Otherwise we say that x and y are distinguishable. Then the relation \u223c L is defined by x \u223c L y iff x and y are indistinguishable."
            },
            "slug": "On-minimizing-finite-automata-Urbanek",
            "title": {
                "fragments": [],
                "text": "On minimizing finite automata"
            },
            "tldr": {
                "abstractSimilarityScore": 61,
                "text": "An efficient algorithm is seen that solves the problem of finding an equivalent DFA with the minimum possible number of states with important applications to the efficiency of procedures that use finite automata."
            },
            "venue": {
                "fragments": [],
                "text": "Bull. EATCS"
            },
            "year": 1989
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1706504"
                        ],
                        "name": "J. Hopcroft",
                        "slug": "J.-Hopcroft",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Hopcroft",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Hopcroft"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1742391"
                        ],
                        "name": "J. Ullman",
                        "slug": "J.-Ullman",
                        "structuredName": {
                            "firstName": "Jeffrey",
                            "lastName": "Ullman",
                            "middleNames": [
                                "D."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Ullman"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 31901407,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "41a88a490d7ba9e383ecb16c4290083413a08258",
            "isKey": false,
            "numCitedBy": 13820,
            "numCiting": 1,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Introduction-to-Automata-Theory,-Languages-and-Hopcroft-Ullman",
            "title": {
                "fragments": [],
                "text": "Introduction to Automata Theory, Languages and Computation"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1979
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39143093"
                        ],
                        "name": "Imre Simon",
                        "slug": "Imre-Simon",
                        "structuredName": {
                            "firstName": "Imre",
                            "lastName": "Simon",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Imre Simon"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 17247970,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "878fac09df3a299e96edf14d87bd5fc6e4231cf7",
            "isKey": false,
            "numCitedBy": 40,
            "numCiting": 9,
            "paperAbstract": {
                "fragments": [],
                "text": "We deene the nondeterministic complexity of a nite automaton and show that there exist, for any integer p 1, automata which need (k 1=p) nondeterministic transitions to spell words of length k. This leads to a subdivision of the family of recognizable M-subsets of a free monoid into a hierarchy whose members are indexed by polynomials, where M denotes the Min{Plus semiring."
            },
            "slug": "The-Nondeterministic-Complexity-of-a-Finite-Simon",
            "title": {
                "fragments": [],
                "text": "The Nondeterministic Complexity of a Finite Automaton"
            },
            "tldr": {
                "abstractSimilarityScore": 76,
                "text": "It is shown that there exist, for any integer p 1, automata which need (k 1=p) nondeterministic transitions to spell words of length k, which leads to a subdivision of the family of recognizable M-subsets of a free monoid into a hierarchy whose members are indexed by polynomials."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1987
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143817739"
                        ],
                        "name": "J. V. Leeuwen",
                        "slug": "J.-V.-Leeuwen",
                        "structuredName": {
                            "firstName": "Jan",
                            "lastName": "Leeuwen",
                            "middleNames": [
                                "van"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. V. Leeuwen"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 96,
                                "start": 84
                            }
                        ],
                        "text": "Finite automata now also constitute a rich chapter of theoretical computer science (Perrin, 1990)."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 60900587,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "b6c4aca87190c98af04c8a081a000ad55bfcf9a5",
            "isKey": false,
            "numCitedBy": 181,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "\"Of all the books I have covered in the Forum to date, this set is the most unique and possibly the most useful to the SIGACT community, in support both of teaching and research.... The books can be used by anyone wanting simply to gain an understanding of one of these areas, or by someone desiring to be in research in a topic, or by instructors wishing to find timely information on a subject they are teaching outside their major areas of expertise.\" -- Rocky Ross, \"SIGACT News\" \"This is a reference which has a place in every computer science library.\" -- Raymond Lauzzana, \"Languages of Design\" The Handbook of Theoretical Computer Science provides professionals and students with a comprehensive overview of the main results and developments in this rapidly evolving field. Volume A covers models of computation, complexity theory, data structures, and efficient computation in many recognized subdisciplines of theoretical computer science. Volume B takes up the theory of automata and rewriting systems, the foundations of modern programming languages, and logics for program specification and verification, and presents several studies on the theoretic modeling of advanced information processing. The two volumes contain thirty-seven chapters, with extensive chapter references and individual tables of contents for each chapter. There are 5,387 entry subject indexes that include notational symbols, and a list of contributors and affiliations in each volume."
            },
            "slug": "Formal-models-and-semantics-Leeuwen",
            "title": {
                "fragments": [],
                "text": "Formal models and semantics"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "The Handbook of Theoretical Computer Science provides professionals and students with a comprehensive overview of the main results and developments in this rapidly evolving field."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1990
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "78659204"
                        ],
                        "name": "M. Mohri",
                        "slug": "M.-Mohri",
                        "structuredName": {
                            "firstName": "Mehryar",
                            "lastName": "Mohri",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Mohri"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 182,
                                "start": 170
                            }
                        ],
                        "text": "The algorithm extends to the case of transducers outputting weights our determinization algorithm for string-to-string transducers representing psubsequential functions (Mohri, 1994c)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 219,
                                "start": 207
                            }
                        ],
                        "text": "In all those areas, the determinization algorithm can be used to obtain a p-subsequential transducer (Mohri, 1996b), and the minimization algorithm to reduce the size of the p-subsequential transducer used (Mohri, 1994b)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 34,
                                "start": 22
                            }
                        ],
                        "text": "Both determinization (Mohri, 1994c) and minimization algorithms (Mohri, 1994b) have been defined for the class of p-subsequential transducers which includes\nMohri Transducers in Language and Speech\nsequential string-to-string transducers."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 93,
                                "start": 81
                            }
                        ],
                        "text": "In order to deal with ambiguities one can introduce p-subsequential transducers (Mohri, 1994a), namely transducers provided with at most p final output strings at each final state."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 155,
                                "start": 143
                            }
                        ],
                        "text": "Finite-state machines are also currently used to represent local syntactic constraints (Silberztein, 1993; Roche, 1993; Karlsson et al., 1995; Mohri, 1994d)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 1317095,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "fa07ee8a7d2b391e7824b2d233de15311399697a",
            "isKey": false,
            "numCitedBy": 25,
            "numCiting": 24,
            "paperAbstract": {
                "fragments": [],
                "text": "Local grammars can be represented in a very convenient way by automata. This paper describes and illustrates an efficient algorithm for the application of local grammars put in this form to lemmatized texts."
            },
            "slug": "Syntactic-Analysis-by-Local-Grammars-Automata:-an-Mohri",
            "title": {
                "fragments": [],
                "text": "Syntactic Analysis by Local Grammars Automata: an Efficient Algorithm"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "An efficient algorithm for the application of local grammars put in this form to lemmatized texts is described and illustrated."
            },
            "venue": {
                "fragments": [],
                "text": "ArXiv"
            },
            "year": 1994
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143687367"
                        ],
                        "name": "B. Watson",
                        "slug": "B.-Watson",
                        "structuredName": {
                            "firstName": "Bruce",
                            "lastName": "Watson",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Watson"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "This nice result has also been proved more recently in elegant papers by Bauer (1988) and  Urbanek (1989) ."
                    },
                    "intents": [
                        {
                            "id": "result"
                        }
                    ]
                }
            ],
            "corpusId": 117770904,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "c25143a60f9b1b49c3d7609df08690e3da45adde",
            "isKey": false,
            "numCitedBy": 78,
            "numCiting": 86,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper presents a taxonomy of nite automata minimization algorithms Brzozowski s elegant minimization algorithm di ers from all other known minimization algorithms and is derived separately All of the remaining algorithms depend upon computing an equivalence relation on states We de ne the equivalence relation the partition that it induces and its complement Additionally some useful properties are derived It is shown that the equivalence relation is the greatest xed point of an equation providing a useful characterization of the required computation We derive an upperbound on the number of approximation steps required to compute the xed point Algorithms computing the equivalence relation or the partition or its complement are derived systematically in the same framework The algorithms include Hopcroft s several algorithms from text books including Hopcroft and Ullman s HU Wood s Wood and Aho Sethi and Ullman s ASU and several new algorithms or variants of existing algorithms Reprinted with corrections"
            },
            "slug": "A-taxonomy-of-finite-automata-minimization-Watson",
            "title": {
                "fragments": [],
                "text": "A taxonomy of finite automata minimization algorithms"
            },
            "tldr": {
                "abstractSimilarityScore": 61,
                "text": "This paper presents a taxonomy of nite automata minimization algorithms and shows that the equivalence relation is the greatest xed point of an equation providing a useful characterization of the required computation."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1993
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1744885"
                        ],
                        "name": "C. Reutenauer",
                        "slug": "C.-Reutenauer",
                        "structuredName": {
                            "firstName": "Christophe",
                            "lastName": "Reutenauer",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Reutenauer"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2362352"
                        ],
                        "name": "M. Sch\u00fctzenberger",
                        "slug": "M.-Sch\u00fctzenberger",
                        "structuredName": {
                            "firstName": "Marcel",
                            "lastName": "Sch\u00fctzenberger",
                            "middleNames": [
                                "Paul"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Sch\u00fctzenberger"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                }
            ],
            "citationContexts": [],
            "corpusId": 124038888,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "60e615ef713f6bf18f7c4a6e76a14cc1badfcfec",
            "isKey": false,
            "numCitedBy": 13,
            "numCiting": 9,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Varieties-and-rational-functions-Reutenauer-Sch\u00fctzenberger",
            "title": {
                "fragments": [],
                "text": "Varieties and rational functions"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145293233"
                        ],
                        "name": "S. Ginsburg",
                        "slug": "S.-Ginsburg",
                        "structuredName": {
                            "firstName": "Seymour",
                            "lastName": "Ginsburg",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Ginsburg"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "16974903"
                        ],
                        "name": "G. F. Rose",
                        "slug": "G.-F.-Rose",
                        "structuredName": {
                            "firstName": "Gene",
                            "lastName": "Rose",
                            "middleNames": [
                                "F."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. F. Rose"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 34,
                                "start": 11
                            }
                        ],
                        "text": "Theorem 3 (Ginsburg and Rose, 1966) Let f be a rational function mapping to . f is sequential iff there exists a positive integer K such that:8u 2 ;8a 2 ; 9w 2 ; jwj K : f(ua) = f(u)w (2)\n1 We denote by jwj the length of a string w.\nComputational Linguistics Volume 23, Number\nIn other words, for\u2026"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 47,
                                "start": 23
                            }
                        ],
                        "text": "This combined with the second condition implies that each fi is subsequential."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 123321315,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "8c6c5853a0fac2df5966f65f325a957b04a1b25a",
            "isKey": false,
            "numCitedBy": 38,
            "numCiting": 8,
            "paperAbstract": {
                "fragments": [],
                "text": "A generalized sequential machine (abbreviated gsm) is a 6-tuple (K, \u2211, \u0394, \u03b4, \u03bb, p1), where K, \u2211, \u0394 are finite non-empty sets (of \u201cstates,\u201d \u201cinputs,\u201d and \u201coutputs\u201d respectively), \u03b4 (the \u201cnext state\u201d function) is a mapping of K X \u2211 into K, \u03bb (the \u201coutput\u201d function) is a mapping of K X \u2211 into \u0394*, and p1 (the \u201cstart\u201c state) is a distinguished element of K."
            },
            "slug": "A-Characterization-of-Machine-Mappings-Ginsburg-Rose",
            "title": {
                "fragments": [],
                "text": "A Characterization of Machine Mappings"
            },
            "venue": {
                "fragments": [],
                "text": "Canadian Journal of Mathematics"
            },
            "year": 1966
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2082433704"
                        ],
                        "name": "Christophe Reutenauer",
                        "slug": "Christophe-Reutenauer",
                        "structuredName": {
                            "firstName": "Christophe",
                            "lastName": "Reutenauer",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Christophe Reutenauer"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144786330"
                        ],
                        "name": "M. Sch\u00fctzenberger",
                        "slug": "M.-Sch\u00fctzenberger",
                        "structuredName": {
                            "firstName": "Marcel",
                            "lastName": "Sch\u00fctzenberger",
                            "middleNames": [
                                "Paul"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Sch\u00fctzenberger"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 36018860,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "7104361d850712f1e0a9a73a13f76466d9b6b347",
            "isKey": false,
            "numCitedBy": 18,
            "numCiting": 4,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Vari\u00e9t\u00e9s-et-fonctions-rationnelles-Reutenauer-Sch\u00fctzenberger",
            "title": {
                "fragments": [],
                "text": "Vari\u00e9t\u00e9s et fonctions rationnelles"
            },
            "venue": {
                "fragments": [],
                "text": "Theor. Comput. Sci."
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1695440"
                        ],
                        "name": "M. Thorup",
                        "slug": "M.-Thorup",
                        "structuredName": {
                            "firstName": "Mikkel",
                            "lastName": "Thorup",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Thorup"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 5221089,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "d8b7f3a6b7a7ffd16d17b028c97a0e53df50eea8",
            "isKey": false,
            "numCitedBy": 168,
            "numCiting": 46,
            "paperAbstract": {
                "fragments": [],
                "text": "Priority queues are some of the most fundamental data structures. For example, they are used directly for task scheduling in operating systems. Moreover, they are essential to greedy algorithms. We study the complexity of integer priority queue operations on a RAM with arbitrary word size, modeling the possibilities in standard imperative programming languages such as C. We present exponential improvements over previous bounds, and we show tight relations to sorting. \nOur first result is a RAM priority queue supporting find-min in constant time and insert and delete-min in time O(log log n), where n is the current number of keys in the queue. This is an exponential improvement over the $O(\\sqrt{\\log n})$ bound of Fredman and Willard [ Proceedings of the 22nd ACM Symposium on the Theory of Computing, Baltimore, MD, pp. 1--7]. Plugging this priority queue into Dijkstra's algorithm gives an O(mlog log m) algorithm for the single source shortest path problem on a graph with m edges, as compared with the previous $O(m\\sqrt{\\log m})$ bound based on Fredman and Willard's priority queue. The above bounds assume $O(n 2^{{\\varepsilon} w})$ space, where w is the word length and ${\\varepsilon}>0$. They can, however, be achieved in linear space using randomized hashing. \nOur second result is a general equivalence between sorting and priority queues. A priority queue is monotone if the minimum is nondecreasing over time, as in many greedy algorithms. We show that on a RAM, the amortized operation cost of a monotone priority queue is equivalent to the per-key cost of sorting. For example, the equivalence implies that the single source shortest paths problem on a graph with m edges is no harder than that of sorting m keys. With the current RAM sorting, this gives an O(m log log m) time bound, as above, but the relation holds regardless of the future developments in RAM sorting. \nFrom the equivalence result, for any fixed ${\\varepsilon}>0$, we derive a randomized monotone $O(\\sqrt{\\log n}^{1+{\\varepsilon}})$ priority queue with expected constant time decrease-key. Plugging this into Dijkstra's algorithm gives an $O(n\\sqrt{\\log n}^{1+{\\varepsilon}}+m)$ algorithm for the single source shortest path problem on a graph with n nodes and m edges, complementing the above O(mlog log m) algorithm if $m\\gg n$. This improves the O(nlog n/log log n + m) bound by Fredman and Willard [Proceedings of the 31st IEEE Symposium on the Foundations of Computer Science, St. Louis, MO, 1990, pp. 719--725], based on their O(log n/log log n) priority queue with constant decrease-key."
            },
            "slug": "On-RAM-priority-queues-Thorup",
            "title": {
                "fragments": [],
                "text": "On RAM priority queues"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "On a RAM, the amortized operation cost of a monotone priority queue is equivalent to the per-key cost of sorting, and the equivalence implies that the single source shortest paths problem on a graph with m edges is no harder than that of sorting m keys."
            },
            "venue": {
                "fragments": [],
                "text": "SODA '96"
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1715952"
                        ],
                        "name": "A. Aho",
                        "slug": "A.-Aho",
                        "structuredName": {
                            "firstName": "Alfred",
                            "lastName": "Aho",
                            "middleNames": [
                                "V."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Aho"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144281449"
                        ],
                        "name": "R. Sethi",
                        "slug": "R.-Sethi",
                        "structuredName": {
                            "firstName": "Ravi",
                            "lastName": "Sethi",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Sethi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1742391"
                        ],
                        "name": "J. Ullman",
                        "slug": "J.-Ullman",
                        "structuredName": {
                            "firstName": "Jeffrey",
                            "lastName": "Ullman",
                            "middleNames": [
                                "D."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Ullman"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 146,
                                "start": 118
                            }
                        ],
                        "text": "Applications such as compiler construction have shown deterministic finite automata to be very efficient in practice (Aho, Sethi, and Ullman, 1986)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 42981739,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "b7f33d55d94e75a554251fe7dc07f1d7b4db8e1a",
            "isKey": false,
            "numCitedBy": 9130,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "1 Introduction 1.1 Language Processors 1.2 The Structure of a Compiler 1.3 The Evolution of Programming Languages 1.4 The Science of Building a Compiler 1.5 Applications of Compiler Technology 1.6 Programming Language Basics 1.7 Summary of Chapter 1 1.8 References for Chapter 1 2 A Simple Syntax-Directed Translator 2.1 Introduction 2.2 Syntax Definition 2.3 Syntax-Directed Translation 2.4 Parsing 2.5 A Translator for Simple Expressions 2.6 Lexical Analysis 2.7 Symbol Tables 2.8 Intermediate Code Generation 2.9 Summary of Chapter 2 3 Lexical Analysis 3.1 The Role of the Lexical Analyzer 3.2 Input Buffering 3.3 Specification of Tokens 3.4 Recognition of Tokens 3.5 The Lexical-Analyzer Generator Lex 3.6 Finite Automata 3.7 From Regular Expressions to Automata 3.8 Design of a Lexical-Analyzer Generator 3.9 Optimization of DFA-Based Pattern Matchers 3.10 Summary of Chapter 3 3.11 References for Chapter 3 4 Syntax Analysis 4.1 Introduction 4.2 Context-Free Grammars 4.3 Writing a Grammar 4.4 Top-Down Parsing 4.5 Bottom-Up Parsing 4.6 Introduction to LR Parsing: Simple LR 4.7 More Powerful LR Parsers 4.8 Using Ambiguous Grammars 4.9 Parser Generators 4.10 Summary of Chapter 4 4.11 References for Chapter 4 5 Syntax-Directed Translation 5.1 Syntax-Directed Definitions 5.2 Evaluation Orders for SDD's 5.3 Applications of Syntax-Directed Translation 5.4 Syntax-Directed Translation Schemes 5.5 Implementing L-Attributed SDD's 5.6 Summary of Chapter 5 5.7 References for Chapter 5 6 Intermediate-Code Generation 6.1 Variants of Syntax Trees 6.2 Three-Address Code 6.3 Types and Declarations 6.4 Translation of Expressions 6.5 Type Checking 6.6 Control Flow 6.7 Backpatching 6.8 Switch-Statements 6.9 Intermediate Code for Procedures 6.10 Summary of Chapter 6 6.11 References for Chapter 6 7 Run-Time Environments 7.1 Storage Organization 7.2 Stack Allocation of Space 7.3 Access to Nonlocal Data on the Stack 7.4 Heap Management 7.5 Introduction to Garbage Collection 7.6 Introduction to Trace-Based Collection 7.7 Short-Pause Garbage Collection 7.8 Advanced Topics in Garbage Collection 7.9 Summary of Chapter 7 7.10 References for Chapter 7 8 Code Generation 8.1 Issues in the Design of a Code Generator 8.2 The Target Language 8.3 Addresses in the Target Code 8.4 Basic Blocks and Flow Graphs 8.5 Optimization of Basic Blocks 8.6 A Simple Code Generator 8.7 Peephole Optimization 8.8 Register Allocation and Assignment 8.9 Instruction Selection by Tree Rewriting 8.10 Optimal Code Generation for Expressions 8.11 Dynamic Programming Code-Generation 8.12 Summary of Chapter 8 8.13 References for Chapter 8 9 Machine-Independent Optimizations 9.1 The Principal Sources of Optimization 9.2 Introduction to Data-Flow Analysis 9.3 Foundations of Data-Flow Analysis 9.4 Constant Propagation 9.5 Partial-Redundancy Elimination 9.6 Loops in Flow Graphs 9.7 Region-Based Analysis 9.8 Symbolic Analysis 9.9 Summary of Chapter 9 9.10 References for Chapter 9 10 Instruction-Level Parallelism 10.1 Processor Architectures 10.2 Code-Scheduling Constraints 10.3 Basic-Block Scheduling 10.4 Global Code Scheduling 10.5 Software Pipelining 10.6 Summary of Chapter 10 10.7 References for Chapter 10 11 Optimizing for Parallelism and Locality 11.1 Basic Concepts 11.2 Matrix Multiply: An In-Depth Example 11.3 Iteration Spaces 11.4 Affine Array Indexes 11.5 Data Reuse 11.6 Array Data-Dependence Analysis 11.7 Finding Synchronization-Free Parallelism 11.8 Synchronization Between Parallel Loops 11.9 Pipelining 11.10 Locality Optimizations 11.11 Other Uses of Affine Transforms 11.12 Summary of Chapter 11 11.13 References for Chapter 11 12 Interprocedural Analysis 12.1 Basic Concepts 12.2 Why Interprocedural Analysis? 12.3 A Logical Representation of Data Flow 12.4 A Simple Pointer-Analysis Algorithm 12.5 Context-Insensitive Interprocedural Analysis 12.6 Context-Sensitive Pointer Analysis 12.7 Datalog Implementation by BDD's 12.8 Summary of Chapter 12 12.9 References for Chapter 12 A A Complete Front End A.1 The Source Language A.2 Main A.3 Lexical Analyzer A.4 Symbol Tables and Types A.5 Intermediate Code for Expressions A.6 Jumping Code for Boolean Expressions A.7 Intermediate Code for Statements A.8 Parser A.9 Creating the Front End B Finding Linearly Independent Solutions Index"
            },
            "slug": "Compilers:-Principles,-Techniques,-and-Tools-Aho-Sethi",
            "title": {
                "fragments": [],
                "text": "Compilers: Principles, Techniques, and Tools"
            },
            "tldr": {
                "abstractSimilarityScore": 37,
                "text": "This book discusses the design of a Code Generator, the role of the Lexical Analyzer, and other topics related to code generation and optimization."
            },
            "venue": {
                "fragments": [],
                "text": "Addison-Wesley series in computer science / World student series edition"
            },
            "year": 1986
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1738824"
                        ],
                        "name": "J. Berstel",
                        "slug": "J.-Berstel",
                        "structuredName": {
                            "firstName": "Jean",
                            "lastName": "Berstel",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Berstel"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1744885"
                        ],
                        "name": "C. Reutenauer",
                        "slug": "C.-Reutenauer",
                        "structuredName": {
                            "firstName": "Christophe",
                            "lastName": "Reutenauer",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Reutenauer"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 98,
                                "start": 70
                            }
                        ],
                        "text": "We adopt the terminology and notation used in formal language theory (Berstel and Reutenauer, 1988; Kuich and Salomaa, 1986; Salomaa and Soittola, 1978): the image by a formal power series S of a string w is denoted by (S;w) and\ncalled the coefficient of w in S, the notation S =Pw2 (S;w)w is then\u2026"
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [],
                        "text": "Brzozowski (1962) showed that determinization can be used to minimize automata."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 36524059,
            "fieldsOfStudy": [
                "Biology"
            ],
            "id": "d26844d389df6aa01152bbe31832ff4ab73f5b01",
            "isKey": false,
            "numCitedBy": 797,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "I. Rational Series.- 1 Semirings.- 2 Formal Series.- 3 The Topology of K\"X\".- 4 Rational Series.- 5 Recognizable Series.- 6 The Fundamental Theorem.- Exercises for Chapter I.- Notes to Chapter I.- II. Minimization.- 1 Syntactic Ideals.- 2 Reduced Linear Representations.- 3 The Reduction Algorithm.- Exercises for Chapter II.- Notes to Chapter II.- III. Series and Languages.- 1 The Theorem of Kleene.- 2 Series and Rational Languages.- 3 Supports.- 4 Iteration.- 5 Complementation.- Exercises for Chapter III.- Notes to Chapter III.- IV. Rational Series in One Variable.- 1 Rational Functions.- 2 The Exponential Polynomial.- 3 A Theorem of Polya.- 4 A Theorem of Skolem, Mahler and Lech.- Notes to Chapter IV.- V. Changing the Semiring.- 1 Rational Series over a Principal Ring.- 2 Positive Rational Series.- 3 Fatou Extensions.- Exercises for Chapter V.- Notes to Chapter V.- VI. Decidability.- 1 Problems of Supports.- 2 Growth.- Exercises for Chapter VI.- Notes to Chapter VI.- VII. Noncommutative Polynomials.- 1 The Weak Algorithm.- 2 Continuant Polynomials.- 3 Inertia.- 4 Gauss's Lemma.- Exercises for Chapter VII.- Notes to Chapter VII.- VIII. Codes and Formal Series.- 1 Codes.- 2 Completeness.- 3 The Degree of a Code.- 4 Factorization.- Exercises for Chapter VIII.- Notes to Chapter VIII.- References."
            },
            "slug": "Rational-series-and-their-languages-Berstel-Reutenauer",
            "title": {
                "fragments": [],
                "text": "Rational series and their languages"
            },
            "tldr": {
                "abstractSimilarityScore": 46,
                "text": "This chapter discusses the development of Rational Series over a Principal Ring, a model based on the model developed in Chapter I, and its applications to Languages and Codes."
            },
            "venue": {
                "fragments": [],
                "text": "EATCS monographs on theoretical computer science"
            },
            "year": 1988
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2425578"
                        ],
                        "name": "L. Karttunen",
                        "slug": "L.-Karttunen",
                        "structuredName": {
                            "firstName": "Lauri",
                            "lastName": "Karttunen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Karttunen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1803660"
                        ],
                        "name": "R. Kaplan",
                        "slug": "R.-Kaplan",
                        "structuredName": {
                            "firstName": "Ronald",
                            "lastName": "Kaplan",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Kaplan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1809816"
                        ],
                        "name": "A. Zaenen",
                        "slug": "A.-Zaenen",
                        "structuredName": {
                            "firstName": "Annie",
                            "lastName": "Zaenen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Zaenen"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 182,
                                "start": 147
                            }
                        ],
                        "text": "\u2026from the construction of lexical analyzers (Silberztein, 1993) and the compilation of morphological and phonological rules (Kaplan and Kay, 1994; Karttunen, Kaplan, and Zaenen, 1992) to speech processing (Mohri, Pereira, and Riley, 1996) show the usefulness of finite-state machines in many\u2026"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 6658384,
            "fieldsOfStudy": [
                "Linguistics"
            ],
            "id": "eaaeca3b38df3450144b674a28a02e4a2d85785c",
            "isKey": false,
            "numCitedBy": 171,
            "numCiting": 22,
            "paperAbstract": {
                "fragments": [],
                "text": "Two-Level Morphology with Composition Lauri Karttunen, Ronald M. Kaplan, and Annie Zaenen Xerox Palo Alto Research Center Center for the Study of language and Information StanJbrd University 1. Limitations of \"Kimmo\" systems The advent of two-level morphology (Koskenniemi [1], Karttunen [2], Antworth [3], Ritchie et al. [4]) has made it relatively easy to develop adequate morphological (or at least morphographical) descriptions for natural languages, clearly superior to earlier \"cut-and-paste\" approaches to mor- phology. Most of the existing \"Kimmo\" systems developed within this paradigm consist of \u2022 linked lexicons stored as annotated letter trees \u2022 morphological information on the leaf nodes of trees \u2022 transducers that encode morphological alternations An analysis of an inflected word form is produced by mapping the input form to a sequence of lexical forms through the transducers and by composing some out- put from the annotations on the leaf nodes of the lexical paths that were traversed. Comprehensive morphological descrip- tions of this type have been developed for several languages including Finnish, Swedish, Russian, English, Swahili, and Arabic. Although they have several good features, these Kimmo-systems also have some limitations. The ones we want to ad- dress in this paper are the following: (1) Lexical representations tend to be arbitrary. Because it is difficult to write and test two-level systems that map between pairs of radically dissimilar forms, lexical representations in existing two-level analyzers tend to stay close to the surface forms. This is not a problem for morpho- logically simple languages like English because, for most words, inflected forms are very similar to the canonical dictionary entry. Except for a small number of irregular verbs and nouns, it is not difficult to create a two-level description for English in which lexical forms coincide with the canonical citation forms found in a dictionary. However, current analyzers for mor- phologically more complex languages (Finnish and Russian, for example) are not as satisfying in this respect. In these systems, lexical forms typically contain diacritic markers and special symbols; they are not real words in the language. For example, in Finnish the lexical counterpart of otin 'I took' might be rendered as otTallln, where T, al, and I1 are an arbitrary encoding of morpho- logical alternations that determine the allomorphs of the stem and the past tense morpheme. The canonical citation form ottaa 'to take' is composed from annotations on the leaf nodes of the letter trees that are linked to match the input. It is not in any direct way related to the lexical form produced by the transducers. (2) Morphological categories are not directly encoded as part of the lexical form. Instead of morphemes like Plural or Past, we typically see suffix strings like +s, and +ed, which do not by themselves indi- cate what morpheme they express. Different realizations of the same morpho- logical category are often represented as different even on the lexical side. These characteristics lead to some un- desirable consequences: ACRES DE COLING-92, NANTES, 23-28 AO~' 1992 1 4 1 PROC. OF COLING-92, NA~rr~s, AU6.23-28, 1992"
            },
            "slug": "Two-Level-Morphology-with-Composition-Karttunen-Kaplan",
            "title": {
                "fragments": [],
                "text": "Two-Level Morphology with Composition"
            },
            "tldr": {
                "abstractSimilarityScore": 100,
                "text": "Two-Level Morphology with Composition Lauri Karttunen, Ronald M. Kaplan, and Annie Zaenen Xerox Palo Alto Research Center Center for the Study of language and Information StanJbrd University 1."
            },
            "venue": {
                "fragments": [],
                "text": "COLING"
            },
            "year": 1992
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1724242"
                        ],
                        "name": "A. Nerode",
                        "slug": "A.-Nerode",
                        "structuredName": {
                            "firstName": "Anil",
                            "lastName": "Nerode",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Nerode"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 122862946,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "ed56719962b555b7c37dc9ab3e9920ba9a21397c",
            "isKey": false,
            "numCitedBy": 485,
            "numCiting": 1,
            "paperAbstract": {
                "fragments": [],
                "text": "Let R be a nonempty set, let N consist of all non-negative rational integers, and denote by RN the set of all functions on N to R. If R is a ring, a map M: R\"\u2014>P^ is linear if M(rxfx+r2f2)=rx(Mfx) +r2(Mf2) for rx, r2 in R, fx, f2 in RN. For a finite commutative ring with unit we determine which linear transformations M: RN\u2014+RN can be realized by finite automata. More precisely, let A, B he finite nonempty sets. A map M: AN\u2014>BN is an automaton transformation if there exists a finite set Q, maps Mq: A X\u00a3>\u2014><2, Mb: A XQ-*B, elements h in B, q in Q such that corresponding to each/ in AN there exists an h in QN satisfying"
            },
            "slug": "Linear-automaton-transformations-Nerode",
            "title": {
                "fragments": [],
                "text": "Linear automaton transformations"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "For a finite commutative ring with unit the authors determine which linear transformations M: RN\u2014+RN can be realized by finite automata."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1958
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1739643"
                        ],
                        "name": "A. Salomaa",
                        "slug": "A.-Salomaa",
                        "structuredName": {
                            "firstName": "Arto",
                            "lastName": "Salomaa",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Salomaa"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2558906"
                        ],
                        "name": "Matti Soittola",
                        "slug": "Matti-Soittola",
                        "structuredName": {
                            "firstName": "Matti",
                            "lastName": "Soittola",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Matti Soittola"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 151,
                                "start": 125
                            }
                        ],
                        "text": "We adopt the terminology and notation used in formal language theory (Berstel and Reutenauer, 1988; Kuich and Salomaa, 1986; Salomaa and Soittola, 1978): the image by a formal power series S of a string w is denoted by (S;w) and\ncalled the coefficient of w in S, the notation S =Pw2 (S;w)w is then\u2026"
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 152,
                                "start": 69
                            }
                        ],
                        "text": "We adopt the terminology and notation used in formal language theory (Berstel and Reutenauer, 1988; Kuich and Salomaa, 1986; Salomaa and Soittola, 1978): the image by a formal power series S of a string w is denoted by (S;w) and called the coefficient of w in S, the notation S =Pw2 (S;w)w is then used to define a power series by its coefficients, The support of S is the language defined by: supp(S) = fw 2 : (S;w) 6=1g The fundamental theorem of Sch\u00fctzenberger (1961), analogous of the Kleene\u2019s theorem for formal languages, states that a formal power series S is rational iff it is recognizable, that is realizable by a string-to-weight transducer."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 139,
                                "start": 111
                            }
                        ],
                        "text": "The notion of determinization can be generalized to that of -determinization for instance (chapter 3, exercise (Salomaa and Soittola, 1978)) requiring more general algorithms."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 2935720,
            "fieldsOfStudy": [
                "Psychology"
            ],
            "id": "7560519aefdb0fcd0db6bda1794eae9d571c6bc8",
            "isKey": false,
            "numCitedBy": 803,
            "numCiting": 22,
            "paperAbstract": {
                "fragments": [],
                "text": "675 clarity of the exposition and the precision, which leaves no room for uncertainty. The style has sometimes been characterized as austere or severe. It may, occasionally be also somewhat elliptic. The ideas are presented in a most economical fashion and the author does expect the reader to be able to fill in the more obvious details. This permits him to present the leading ideas in an uncluttered way. Finally, while the ultimate verdict on the work, like everything human, belongs to history, those of us, who were fortunate enough to have known Harold Davenport, cannot help remembering also the man. While much of what he was-cultured, articulate, logical-is indeed reflected in his work, not everything is. He was generous with his time and enjoyed (or at least seemed to enjoy) showing Cambridge to his guests. While, to judge by his students, his standards must have been very high, he was quite patient with the more common brand of mankind and made genuine efforts to make himself understood by the less sophisticated reader (see, e.g., his book \"The Higher Arithmetic\"). In fact, this reviewer can recall only one outburst of impatience (or indignation?) of Davenport: it was with mathematicians who claim results, but never publish their proofs, either because they don't have any, or in order to keep their methods as private property of a small group of close collaborators. No names were named. The reviewer wants to take this opportunity to thank Professor D. J. Lewis for a very helpful letter concerning Davenport which confirmed many and completed some of the reviewer's own recollections. In the early sixties, stimulated by the discoveries of M. P. Sch\u00fbtzenberger, a number of researchers at the University of Paris contributed to a new"
            },
            "slug": "Automata-Theoretic-Aspects-of-Formal-Power-Series-Salomaa-Soittola",
            "title": {
                "fragments": [],
                "text": "Automata-Theoretic Aspects of Formal Power Series"
            },
            "tldr": {
                "abstractSimilarityScore": 49,
                "text": "The style has sometimes been characterized as austere or severe, but the author does expect the reader to be able to fill in the more obvious details and the author permits him to present the leading ideas in an uncluttered way."
            },
            "venue": {
                "fragments": [],
                "text": "Texts and Monographs in Computer Science"
            },
            "year": 1978
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1715952"
                        ],
                        "name": "A. Aho",
                        "slug": "A.-Aho",
                        "structuredName": {
                            "firstName": "Alfred",
                            "lastName": "Aho",
                            "middleNames": [
                                "V."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Aho"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1706504"
                        ],
                        "name": "J. Hopcroft",
                        "slug": "J.-Hopcroft",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Hopcroft",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Hopcroft"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1742391"
                        ],
                        "name": "J. Ullman",
                        "slug": "J.-Ullman",
                        "structuredName": {
                            "firstName": "Jeffrey",
                            "lastName": "Ullman",
                            "middleNames": [
                                "D."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Ullman"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 29599075,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "10a463bb00b44bdd3a8620f2bedb9e1564bfcf32",
            "isKey": false,
            "numCitedBy": 9234,
            "numCiting": 138,
            "paperAbstract": {
                "fragments": [],
                "text": "From the Publisher: \nWith this text, you gain an understanding of the fundamental concepts of algorithms, the very heart of computer science. It introduces the basic data structures and programming techniques often used in efficient algorithms. Covers use of lists, push-down stacks, queues, trees, and graphs. Later chapters go into sorting, searching and graphing algorithms, the string-matching algorithms, and the Schonhage-Strassen integer-multiplication algorithm. Provides numerous graded exercises at the end of each chapter. \n \n \n0201000296B04062001"
            },
            "slug": "The-Design-and-Analysis-of-Computer-Algorithms-Aho-Hopcroft",
            "title": {
                "fragments": [],
                "text": "The Design and Analysis of Computer Algorithms"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "This text introduces the basic data structures and programming techniques often used in efficient algorithms, and covers use of lists, push-down stacks, queues, trees, and graphs."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1974
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144944321"
                        ],
                        "name": "W. Thomas",
                        "slug": "W.-Thomas",
                        "structuredName": {
                            "firstName": "Wolfgang",
                            "lastName": "Thomas",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Thomas"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 96,
                                "start": 84
                            }
                        ],
                        "text": "Finite automata now also constitute a rich chapter of theoretical computer science (Perrin, 1990)."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 34434822,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e0f92ae0658165622819f2eba692f3d59784a24f",
            "isKey": false,
            "numCitedBy": 758,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "Following your need to always fulfil the inspiration to obtain everybody is now simple. Connecting to the internet is one of the short cuts to do. There are so many sources that offer and connect us to other world condition. As one of the products to see in internet, this website becomes a very available place to look for countless handbook of theoretical computer science volume b formal models and semantics sources. Yeah, sources about the books from countries in the world are provided."
            },
            "slug": "Handbook-of-Theoretical-Computer-Science,-Volume-B:-Thomas",
            "title": {
                "fragments": [],
                "text": "Handbook of Theoretical Computer Science, Volume B: Formal Models and Semantics"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "As one of the products to see in internet, this website becomes a very available place to look for countless handbook of theoretical computer science volume b formal models and semantics sources."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1990
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3187053"
                        ],
                        "name": "D. Revuz",
                        "slug": "D.-Revuz",
                        "structuredName": {
                            "firstName": "Dominique",
                            "lastName": "Revuz",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Revuz"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 35936166,
            "fieldsOfStudy": [
                "Business"
            ],
            "id": "0989cee64098407c446f5b6e0aa47e8d4a7e6591",
            "isKey": false,
            "numCitedBy": 160,
            "numCiting": 8,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Minimisation-of-Acyclic-Deterministic-Automata-in-Revuz",
            "title": {
                "fragments": [],
                "text": "Minimisation of Acyclic Deterministic Automata in Linear Time"
            },
            "venue": {
                "fragments": [],
                "text": "Theor. Comput. Sci."
            },
            "year": 1992
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2075836555"
                        ],
                        "name": "Emmanuel Roche",
                        "slug": "Emmanuel-Roche",
                        "structuredName": {
                            "firstName": "Emmanuel",
                            "lastName": "Roche",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Emmanuel Roche"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 118,
                                "start": 107
                            }
                        ],
                        "text": "Finite-state machines are also currently used to represent local syntactic constraints (Silberztein, 1993; Roche, 1993; Karlsson et al., 1995; Mohri, 1994d)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 170084537,
            "fieldsOfStudy": [
                "Philosophy"
            ],
            "id": "b9167023806d16b8b76f5be04964a704e9709771",
            "isKey": false,
            "numCitedBy": 64,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "A de rares exceptions pres, le cheminement de l'analyse syntaxique automatique suit la creation de modeles de grammaires formelles (gb, hpsg, etc. ) censees refleter les mecanismes internes de la langue. Pour notre part nous avons utilise le formalisme le plus simple et le plus neutre possible, celui des listes, listes que sont les dictionnaires morphologiques et syntaxiques. Ces dictionnaires forment cependant des listes trop importantes pour etre manipulees directement. La notion d'automate, et plus particulierement celle de transducteur, permet de pallier a cet inconvenient en factorisant un tres grand nombre d'informations communes a plusieurs entrees. Nous avons represente par un transducteur un dictionnaire syntaxique de plus de 2000000 d'entrees. Ce dictionnaire, dont la taille est appelee a augmenter tres notablement est appele delsyn, le transducteur qui le representera f-delsyn. Par ailleurs, de telles representations conduisent a des programmes d'analyse extremement simples, l'analyse d'une phrase ph consistant simplement a appliquer la fonction f-delsyn cycliquement a un automate representant ph jusqu'a l'obtention d'un point fixe. L'application cyclique d'une transduction peut en effet effectuer une analyse descendante d'identification de l'element predicatif de la phrase (le verbe en general) puis passer a l'analyse de chacun des arguments de cet element (le sujet et les complements le plus souvent). Mais une transduction peut egalement simuler une analyse de type ascendant qui reconnait des segments de plus en plus grand; enfin nous verrons qu'une transduction peut egalement appliquer des regles de grammaires locales dans une analyse qu'on peut dire transversale par rapport aux deux types precedents"
            },
            "slug": "Analyse-syntaxique-transformationnelle-du-francais-Roche",
            "title": {
                "fragments": [],
                "text": "Analyse syntaxique transformationnelle du francais par transducteurs et lexique-grammaire"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1993
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1732982"
                        ],
                        "name": "R. Ahuja",
                        "slug": "R.-Ahuja",
                        "structuredName": {
                            "firstName": "Ravindra",
                            "lastName": "Ahuja",
                            "middleNames": [
                                "K."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Ahuja"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1698752"
                        ],
                        "name": "K. Mehlhorn",
                        "slug": "K.-Mehlhorn",
                        "structuredName": {
                            "firstName": "Kurt",
                            "lastName": "Mehlhorn",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Mehlhorn"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1795576"
                        ],
                        "name": "J. Orlin",
                        "slug": "J.-Orlin",
                        "structuredName": {
                            "firstName": "James",
                            "lastName": "Orlin",
                            "middleNames": [
                                "B."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Orlin"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1721050"
                        ],
                        "name": "R. Tarjan",
                        "slug": "R.-Tarjan",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "Tarjan",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Tarjan"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "In case the maximum output weight W is small, one can use the algorithm of Ahuja et al. (1988). The complexity of pushing is then O(jEj + jQjpjW j)."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 5499589,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "b0bcc6dc67f33f9957758abdaef2d43b74256b46",
            "isKey": false,
            "numCitedBy": 531,
            "numCiting": 35,
            "paperAbstract": {
                "fragments": [],
                "text": "Efficient implementations of Dijkstra's shortest path algorithm are investigated. A new data structure, called the <italic>radix heap</italic>, is proposed for use in this algorithm. On a network with <italic>n</italic> vertices, <italic>m</italic> edges, and nonnegative integer arc costs bounded by <italic>C</italic>, a one-level form of radix heap gives a time bound for Dijkstra's algorithm of <italic>O</italic>(<italic>m</italic> + <italic>n</italic> log <italic>C</italic>). A two-level form of radix heap gives a bound of <italic>O</italic>(<italic>m</italic> + <italic>n</italic> log <italic>C</italic>/log log <italic>C</italic>). A combination of a radix heap and a previously known data structure called a <italic>Fibonacci heap</italic> gives a bound of <italic>O</italic>(<italic>m</italic> + <italic>n</italic>a @@@@log <italic>C</italic>). The best previously known bounds are <italic>O</italic>(<italic>m</italic> + <italic>n</italic> log <italic>n</italic>) using Fibonacci heaps alone and <italic>O</italic>(<italic>m</italic> log log <italic>C</italic>) using the priority queue structure of Van Emde Boas et al. [ 17]."
            },
            "slug": "Faster-algorithms-for-the-shortest-path-problem-Ahuja-Mehlhorn",
            "title": {
                "fragments": [],
                "text": "Faster algorithms for the shortest path problem"
            },
            "tldr": {
                "abstractSimilarityScore": 91,
                "text": "Efficient implementations of Dijkstra's shortest path algorithm are investigated and a new data structure, called the radix heap, is proposed for use in this algorithm."
            },
            "venue": {
                "fragments": [],
                "text": "JACM"
            },
            "year": 1990
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144786330"
                        ],
                        "name": "M. Sch\u00fctzenberger",
                        "slug": "M.-Sch\u00fctzenberger",
                        "structuredName": {
                            "firstName": "Marcel",
                            "lastName": "Sch\u00fctzenberger",
                            "middleNames": [
                                "Paul"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Sch\u00fctzenberger"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                }
            ],
            "citationContexts": [],
            "corpusId": 42465514,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "f8100a428c8c5f0527591bae2c3583176c6ba979",
            "isKey": false,
            "numCitedBy": 99,
            "numCiting": 4,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Sur-une-Variante-des-Fonctions-Sequentielles-Sch\u00fctzenberger",
            "title": {
                "fragments": [],
                "text": "Sur une Variante des Fonctions Sequentielles"
            },
            "venue": {
                "fragments": [],
                "text": "Theor. Comput. Sci."
            },
            "year": 1977
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1738399"
                        ],
                        "name": "D. Krob",
                        "slug": "D.-Krob",
                        "structuredName": {
                            "firstName": "Daniel",
                            "lastName": "Krob",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Krob"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 16304008,
            "fieldsOfStudy": [
                "Economics"
            ],
            "id": "d4a2b8e6c81c18a20f0d3ab2c70b3d92450e881d",
            "isKey": false,
            "numCitedBy": 186,
            "numCiting": 30,
            "paperAbstract": {
                "fragments": [],
                "text": "HAL is a multi-disciplinary open access archive for the deposit and dissemination of scientific research documents, whether they are published or not. The documents may come from teaching and research institutions in France or abroad, or from public or private research centers. L\u2019archive ouverte pluridisciplinaire HAL, est destin\u00e9e au d\u00e9p\u00f4t et \u00e0 la diffusion de documents scientifiques de niveau recherche, publi\u00e9s ou non, \u00e9manant des \u00e9tablissements d\u2019enseignement et de recherche fran\u00e7ais ou \u00e9trangers, des laboratoires publics ou priv\u00e9s. The equality problem for rational series with multiplicities in the tropical semiring is undecidable Daniel Krob"
            },
            "slug": "The-Equality-Problem-for-Rational-Series-with-in-is-Krob",
            "title": {
                "fragments": [],
                "text": "The Equality Problem for Rational Series with Multiplicities in the tropical Semiring is Undecidable"
            },
            "tldr": {
                "abstractSimilarityScore": 100,
                "text": "HAL is a multi-disciplinary open access archive for the deposit and dissemination of scientific research documents, whether they are published or not."
            },
            "venue": {
                "fragments": [],
                "text": "Int. J. Algebra Comput."
            },
            "year": 1994
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 161,
                                "start": 149
                            }
                        ],
                        "text": "As an example, a French morphological dictionary of about 21:2 Mb can be compiled into ap-subsequential transducer of size 1:3 Mb, in a few minutes (Mohri, 1996b)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 114,
                                "start": 102
                            }
                        ],
                        "text": "In all those areas, the determinization algorithm can be used to obtain a p-subsequential transducer (Mohri, 1996b), and the minimization algorithm to reduce the size of the p-subsequential transducer used (Mohri, 1994b)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [],
                        "text": "Classical and new theorems help to indicate the usefulness of these devices as well as their characterization."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 17,
                                "start": 5
                            }
                        ],
                        "text": "See (Mohri, 1996b) for a full description of this algorithm."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 132,
                                "start": 120
                            }
                        ],
                        "text": "For a more detailed overview of the applications of sequential string to string transducers to language processing see (Mohri, 1996a)."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": true,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Finite State Devices in Natural Language Processing, chapter On The Use of Sequential Transducers in Natural Language Processing"
            },
            "venue": {
                "fragments": [],
                "text": "Finite State Devices in Natural Language Processing, chapter On The Use of Sequential Transducers in Natural Language Processing"
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1730989"
                        ],
                        "name": "J. Brzozowski",
                        "slug": "J.-Brzozowski",
                        "structuredName": {
                            "firstName": "Janusz",
                            "lastName": "Brzozowski",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Brzozowski"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 29,
                                "start": 11
                            }
                        ],
                        "text": "Theorem 16 (Brzozowski, 1962) Let A be a non-deterministic automaton."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 118363215,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "94def4233e1e8f15bab72e82708a03fd37233b14",
            "isKey": false,
            "numCitedBy": 312,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Canonical-regular-expressions-and-minimal-state-for-Brzozowski",
            "title": {
                "fragments": [],
                "text": "Canonical regular expressions and minimal state graphs for definite events"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1962
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1684537"
                        ],
                        "name": "W. Kuich",
                        "slug": "W.-Kuich",
                        "structuredName": {
                            "firstName": "Werner",
                            "lastName": "Kuich",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Kuich"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1739643"
                        ],
                        "name": "A. Salomaa",
                        "slug": "A.-Salomaa",
                        "structuredName": {
                            "firstName": "Arto",
                            "lastName": "Salomaa",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Salomaa"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 116059266,
            "fieldsOfStudy": [
                "Linguistics"
            ],
            "id": "c7706628fb4cdefc92af7e02ccae36eb24d127e4",
            "isKey": false,
            "numCitedBy": 245,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Semirings,-Automata-and-Languages-Kuich-Salomaa",
            "title": {
                "fragments": [],
                "text": "Semirings, Automata and Languages"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1985
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2362352"
                        ],
                        "name": "M. Sch\u00fctzenberger",
                        "slug": "M.-Sch\u00fctzenberger",
                        "structuredName": {
                            "firstName": "Marcel",
                            "lastName": "Sch\u00fctzenberger",
                            "middleNames": [
                                "Paul"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Sch\u00fctzenberger"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 197441193,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "ad3e393b42f36323da637c1efbb5ea58197be5bc",
            "isKey": false,
            "numCitedBy": 4,
            "numCiting": 1,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Polynomial-decomposition-of-rational-functions-Sch\u00fctzenberger",
            "title": {
                "fragments": [],
                "text": "Polynomial decomposition of rational functions"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1988
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "48903026"
                        ],
                        "name": "Fred Karlsson",
                        "slug": "Fred-Karlsson",
                        "structuredName": {
                            "firstName": "Fred",
                            "lastName": "Karlsson",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Fred Karlsson"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1751188"
                        ],
                        "name": "Atro Voutilainen",
                        "slug": "Atro-Voutilainen",
                        "structuredName": {
                            "firstName": "Atro",
                            "lastName": "Voutilainen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Atro Voutilainen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39879808"
                        ],
                        "name": "A. Anttila",
                        "slug": "A.-Anttila",
                        "structuredName": {
                            "firstName": "Arto",
                            "lastName": "Anttila",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Anttila"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 141,
                                "start": 120
                            }
                        ],
                        "text": "Finite-state machines are also currently used to represent local syntactic constraints (Silberztein, 1993; Roche, 1993; Karlsson et al., 1995; Mohri, 1994d)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 58045464,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "c56091f0330dfd1cbc36aceeae44f85d041c825e",
            "isKey": false,
            "numCitedBy": 512,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "A-language-independent-system-for-parsing-text-Karlsson-Voutilainen",
            "title": {
                "fragments": [],
                "text": "A language-independent system for parsing unrestricted text"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2075322274"
                        ],
                        "name": "M. Gross",
                        "slug": "M.-Gross",
                        "structuredName": {
                            "firstName": "Maurice",
                            "lastName": "Gross",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Gross"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 42293543,
            "fieldsOfStudy": [
                "Linguistics"
            ],
            "id": "15b680649ad50472c79ab39849397b2c2379cb31",
            "isKey": false,
            "numCitedBy": 69,
            "numCiting": 8,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "The-Use-of-Finite-Automata-in-the-Lexical-of-Gross",
            "title": {
                "fragments": [],
                "text": "The Use of Finite Automata in the Lexical Representaion of Natural Language"
            },
            "venue": {
                "fragments": [],
                "text": "Electronic Dictionaries and Automata in Computational Linguistics"
            },
            "year": 1987
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1738824"
                        ],
                        "name": "J. Berstel",
                        "slug": "J.-Berstel",
                        "structuredName": {
                            "firstName": "Jean",
                            "lastName": "Berstel",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Berstel"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 14,
                                "start": 0
                            }
                        ],
                        "text": "Berstel (1979) gives a constructive proof of this theorem."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 41460170,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "ec85c87a38a906f019b67626a89099f5f79d65bf",
            "isKey": false,
            "numCitedBy": 1311,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Transductions-and-context-free-languages-Berstel",
            "title": {
                "fragments": [],
                "text": "Transductions and context-free languages"
            },
            "venue": {
                "fragments": [],
                "text": "Teubner Studienb\u00fccher : Informatik"
            },
            "year": 1979
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1799693"
                        ],
                        "name": "W. Brauer",
                        "slug": "W.-Brauer",
                        "structuredName": {
                            "firstName": "Wilfried",
                            "lastName": "Brauer",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Brauer"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "This nice result has also been proved more recently in elegant papers by Bauer (1988) and Urbanek (1989)."
                    },
                    "intents": [
                        {
                            "id": "result"
                        }
                    ]
                }
            ],
            "corpusId": 32666823,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "897d4965f272214c6c0f23363a567dd75fbbd5ed",
            "isKey": false,
            "numCitedBy": 12,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "On-Minimizing-Finite-Automata-Brauer",
            "title": {
                "fragments": [],
                "text": "On Minimizing Finite Automata"
            },
            "venue": {
                "fragments": [],
                "text": "Bull. EATCS"
            },
            "year": 1988
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2237028"
                        ],
                        "name": "M. Silberztein",
                        "slug": "M.-Silberztein",
                        "structuredName": {
                            "firstName": "M.",
                            "lastName": "Silberztein",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Silberztein"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 130,
                                "start": 113
                            }
                        ],
                        "text": "Their recent applications in natural language processing which range from the construction of lexical analyzers (Silberztein, 1993) and the compilation of morphological and phonological rules (Kaplan and Kay, 1994; Karttunen, Kaplan, and Zaenen, 1992) to speech processing (Mohri, Pereira, and\u2026"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 105,
                                "start": 88
                            }
                        ],
                        "text": "Finite-state machines are also currently used to represent local syntactic constraints (Silberztein, 1993; Roche, 1993; Karlsson et al., 1995; Mohri, 1994d)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 60446621,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "dbfbae07321348a1c09f3d76faddc917ece1cfe1",
            "isKey": false,
            "numCitedBy": 300,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Dictionnaires-\u00e9lectroniques-et-analyse-automatique-Silberztein",
            "title": {
                "fragments": [],
                "text": "Dictionnaires \u00e9lectroniques et analyse automatique de textes : le syst\u00e8me intex"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1993
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Vari~t~s et fonctions ratlonnelles"
            },
            "venue": {
                "fragments": [],
                "text": "Theoretical Computer Science"
            },
            "year": 1995
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Finite State Devices in Natural Language Processing, chapter Weighted Rational Transductions and their Application to Human Language"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1996
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 67,
                                "start": 52
                            }
                        ],
                        "text": "The case of sequential transducers, first proved by Choffrut (1978), can be derived from the general case in a trivial way."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 243,
                                "start": 228
                            }
                        ],
                        "text": "By definition of d, there existsu 2 such that: u1 = uv1; u2 = uv2; and jv1j+ jv2j = d(u1; u2) (13) Hence, (i; u1) = (i; u) + (\u00c6(i; u); v1) (i; u2) = (i; u) + (\u00c6(i; u); v2)\n4 This is an extension of the characterization theorem of Choffrut (1978) for string-to-string functions."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 65,
                                "start": 50
                            }
                        ],
                        "text": "A constructive proof of this theorem was given by Choffrut (1978)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Contributions t~ l'dtude de quelques familles remarquables de fonctions rationnelles"
            },
            "venue": {
                "fragments": [],
                "text": "Contributions t~ l'dtude de quelques familles remarquables de fonctions rationnelles"
            },
            "year": 1978
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Mots. Hermes"
            },
            "venue": {
                "fragments": [],
                "text": "Mots. Hermes"
            },
            "year": 1990
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 130,
                                "start": 113
                            }
                        ],
                        "text": "Their recent applications in natural language processing which range from the construction of lexical analyzers (Silberztein, 1993) and the compilation of morphological and phonological rules (Kaplan and Kay, 1994; Karttunen, Kaplan, and Zaenen, 1992) to speech processing (Mohri, Pereira, and\u2026"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 105,
                                "start": 88
                            }
                        ],
                        "text": "Finite-state machines are also currently used to represent local syntactic constraints (Silberztein, 1993; Roche, 1993; Karlsson et al., 1995; Mohri, 1994d)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Dictionnaires Dictionnaires\u00b4Dictionnaires\u00e9lectroniques et analyse automatique de textes: le syst\u00e8me INTEX"
            },
            "venue": {
                "fragments": [],
                "text": "Dictionnaires Dictionnaires\u00b4Dictionnaires\u00e9lectroniques et analyse automatique de textes: le syst\u00e8me INTEX"
            },
            "year": 1993
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Contributions \u00e0 l\u2019\u00e9tude de quelques familles remarquables de fonctions rationnelles"
            },
            "venue": {
                "fragments": [],
                "text": "Ph.D. thesis, (th\u00e8se de doctorat d\u2019Etat), Universit\u00e9 Paris 7, LITP: Paris, France."
            },
            "year": 1978
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Sur une variante des fonctions s~quentielles. Theoretical Computer Science"
            },
            "venue": {
                "fragments": [],
                "text": "Sur une variante des fonctions s~quentielles. Theoretical Computer Science"
            },
            "year": 1977
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "A finite-state architecture for tokenization and grapheme-to-phoneme conversion in multilingual text analysis"
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of the ACL SIGDAT Workshop"
            },
            "year": 1995
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 130,
                                "start": 113
                            }
                        ],
                        "text": "Their recent applications in natural language processing which range from the construction of lexical analyzers (Silberztein, 1993) and the compilation of morphological and phonological rules (Kaplan and Kay, 1994; Karttunen, Kaplan, and Zaenen, 1992) to speech processing (Mohri, Pereira, and\u2026"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 105,
                                "start": 88
                            }
                        ],
                        "text": "Finite-state machines are also currently used to represent local syntactic constraints (Silberztein, 1993; Roche, 1993; Karlsson et al., 1995; Mohri, 1994d)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Dictionnaires ~lectroniques et analyse automatique de textes: le syst~me INTEX"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1993
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "On ram priority queues On minimizing finite automata"
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of SODA'96"
            },
            "year": 1989
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 123,
                                "start": 100
                            }
                        ],
                        "text": "We adopt the terminology and notation used in formal language theory (Berstel and Reutenauer, 1988; Kuich and Salomaa, 1986; Salomaa and Soittola, 1978): the image by a formal power series S of a string w is denoted by (S;w) and\ncalled the coefficient of w in S, the notation S =Pw2 (S;w)w is then\u2026"
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Semirings, Automata, Languages. Number 5 in EATCS Monographs on Theoretical Computer Science"
            },
            "venue": {
                "fragments": [],
                "text": "Semirings, Automata, Languages. Number 5 in EATCS Monographs on Theoretical Computer Science"
            },
            "year": 1986
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 67,
                                "start": 52
                            }
                        ],
                        "text": "The case of sequential transducers, first proved by Choffrut (1978), can be derived from the general case in a trivial way."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 243,
                                "start": 228
                            }
                        ],
                        "text": "By definition of d, there existsu 2 such that: u1 = uv1; u2 = uv2; and jv1j+ jv2j = d(u1; u2) (13) Hence, (i; u1) = (i; u) + (\u00c6(i; u); v1) (i; u2) = (i; u) + (\u00c6(i; u); v2)\n4 This is an extension of the characterization theorem of Choffrut (1978) for string-to-string functions."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 65,
                                "start": 50
                            }
                        ],
                        "text": "A constructive proof of this theorem was given by Choffrut (1978)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "ContributionsContributions`Contributions\u00e0 l'\u00b4 etude de quelques familles remarquables de fonctions rationnelles"
            },
            "venue": {
                "fragments": [],
                "text": "ContributionsContributions`Contributions\u00e0 l'\u00b4 etude de quelques familles remarquables de fonctions rationnelles"
            },
            "year": 1978
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 123,
                                "start": 100
                            }
                        ],
                        "text": "We adopt the terminology and notation used in formal language theory (Berstel and Reutenauer, 1988; Kuich and Salomaa, 1986; Salomaa and Soittola, 1978): the image by a formal power series S of a string w is denoted by (S;w) and\ncalled the coefficient of w in S, the notation S =Pw2 (S;w)w is then\u2026"
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Semirings, Automata, Languages. EATCS Monographs on Theoretical Computer Science, Number"
            },
            "venue": {
                "fragments": [],
                "text": "Semirings, Automata, Languages. EATCS Monographs on Theoretical Computer Science, Number"
            },
            "year": 1986
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Automata, Languages and Machines, volume A-B"
            },
            "venue": {
                "fragments": [],
                "text": "Automata, Languages and Machines, volume A-B"
            },
            "year": 1974
        }
    ],
    "meta_info": {
        "citationIntent": "all",
        "citationIntentCount": {
            "background": 23,
            "methodology": 21,
            "result": 2
        },
        "citationType": "citedPapers",
        "pageNumber": 1,
        "requestedPageSize": 10,
        "sort": "relevance",
        "totalCitations": 61,
        "totalPages": 7
    },
    "page_url": "https://www.semanticscholar.org/paper/Finite-State-Transducers-in-Language-and-Speech-Mohri/f4cc5563c694355ddcf746ff9a55ccdb22d86a98?sort=total-citations"
}